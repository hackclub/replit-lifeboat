schema {
  query: RootQueryType
  mutation: RootMutationType
  subscription: RootSubscriptionType
}

# The top level entry point for querying the graph
type RootQueryType {
  currentUser: CurrentUser

  # Find a user by id
  user(id: Int!): User

  # Find a Repl by id or url
  repl(id: String, url: String): ReplQueryOutput!

  # Find a team by id
  team(id: Int!): Team

  # Fetches a team organization by id
  teamOrganization(id: Int!): TeamOrganizationOutput!

  # Finds the curent user's seen state of a tour.
  toursSeen(name: String!): ToursSeenQueryResult!

  # Finds recently edited repls
  recentRepls(
    # Number of Repls to return. Maximum of 50
    count: Int = 3

    # Whether to retrieve the user's own Repls or Repls from multiplayer sessions (including Teams Repls)
    filter: RecentReplsFilter
  ): [Repl!]!

  # Finds a board by slug
  boards(slugs: [String]): [Board!]!

  # Find a user by their username
  userByUsername(username: String!): User

  # A team by username
  teamByUsername(username: String!): TeamOutput!

  # Finds all reports on repls, posts, bounties, bounty applications and custom themes.
  boardReports(input: BoardReportsInputType!): BoardReports!

  # Finds a folder from its ID
  replFolderByPath(path: String!, teamName: String): ReplFolder

  # Finds the current user's notifications
  notifications(
    after: String
    count: Int
    seen: Boolean
  ): NotificationConnection!

  # Finds users whose usernames start with a given query
  usernameSearch(
    query: String!
    includeCurrentUser: Boolean
    limit: Int = 10
  ): [User!]!

  # Admin object
  admin: Admin

  # Finds trending posts with repls
  trendingReplPosts(count: Int): [Post!]!

  # ClUI root command
  clui: CluiQuery

  # Returns a unique Repl title for the logged in user
  replTitle(title: String, teamId: Int, orgId: String): String!

  # Replit languages
  languages(search: String, limit: Int, getAll: Boolean): [Language!]!

  # Finds users based on id (with a hard max)
  usersByIds(ids: [Int!]!): [User!]!

  # Replit language
  language(id: String!): Language

  # Returns a Custom Theme found via its ID
  customThemeById(input: CustomThemeByIdInput!): CustomThemeByIdOutput!

  # Returns an array of themes for a given search query
  themesSearch(input: ThemesSearchInput!): ThemesSearchOutput!

  # Find an annotationAnchor by id
  annotationAnchor(id: String!): AnnotationQueryOutput!

  # Returns information about connections to repls which belong to the team with the id provided
  getTeamConnections(
    # The id of the team which connections are to be fetched from
    teamId: Int!
  ): [ReplConnections!]!

  # A site-wide banner message
  siteBanner: Banner

  # The query used to fetch a template share link by its code
  teamTemplateShareLink(
    # The code of the link which we are fetching
    code: String!
  ): TeamTemplateShareLink!

  # Returns existing tags in the order provided
  tags(tags: [String!]!): [Tag!]!

  # Google Classrooms associated with this user's Google account
  getGoogleClassroomCourses: GetGoogleClassroomCoursesOutput

  # Google Classroom students fetched from the API
  getGoogleClassroomStudents(
    courseId: String!
  ): GetGoogleClassroomStudentsOutput
  replTemplateById(id: Int!): ReplTemplateOutput
  languageTemplateRepls: [Repl!]!
    @deprecated(reason: "Use templateRepl2 to search for templates instead")

  # Returns published curriculum for Teams
  curricula: [Curriculum!]!
  curriculumBySlug(slug: String!): CurriculumBySlugOutput!

  # Returns Repl templates and Repls published as templates
  templateRepls2(options: TemplateRepls2QueryOptions!): TemplateRepls2Output!

  # Finds all posts
  replPosts(options: ReplPostsQueryOptions): PostConnection!

  # Returns tags in official and community groups
  tagGroups: TagGroups!
  previewInvoice(input: PreviewInvoiceInput!): PreviewInvoice

  # Search
  search(options: SearchQueryOptions!): SearchQueryOutput!
  threadsByFile(replId: String!, path: String!): ThreadsByFileOutput

  # Get paginated list of user events for current user.
  getUserEventsFeed(after: String, count: Int): UserEventConnection

  # Get a list of tutorial Repls, optionally filtered by category
  tutorialRepls(input: TutorialReplsInput!): TutorialReplsOutput

  # Returns the user's country code
  country: String
  instantGitHubImport(
    input: InstantGitHubImportInput!
  ): InstantGitHubImportOutput!

  # The moderator audit logs
  moderatorAuditLog(
    input: ModeratorAuditLogInputType!
  ): ModeratorAuditLogOutput!

  # Paginated image scan results
  imageScans(
    # Whether to return resolved or unresolved scans
    resolved: Boolean
    after: Int
    count: Int
    threshold: Float!
  ): ImageScansOutput

  # Find comments with spam
  searchSpamComments(
    pattern: String!
    isRegex: Boolean
    count: Int
    dateMin: DateTime
    dateMax: DateTime
    hidden: Boolean
    userId: Int
  ): [ReplComment!]!
  unverifiedEduUsers: [TeacherVerification!]!

  # Finds the Repls associated with a course's lessons
  courseLessonsRepls(
    # The course for which we want lesson Repls
    courseSlug: String!

    # The locale for which we want lesson repls. If not provided, defaults to "en-US"
    locale: String
  ): CourseLessonsReplsOutput

  # Returns a Bounty found via ID
  bountyById(input: BountyByIdInput!): BountyByIdOutput!

  # Returns a Bounty found via ID
  bountySearch(input: BountySearchInput!): BountySearchOutput!

  # Returns a set of recommended Bounties for a user, which can be displayed on the home page
  getRecommendedBountiesForUser(
    input: GetRecommendedBountiesForUserInput!
  ): GetRecommendedBountiesForUserOutput!

  # Returns a BountyApplication found via ID
  bountyApplicationById(
    input: BountyApplicationByIdInput!
  ): BountyApplicationByIdOutput!

  # Returns Bounty applications for a given Bounty
  bountyApplicationSearch(
    input: BountyApplicationSearchInput!
  ): BountyApplicationSearchOutput!

  # Returns Bounty chat messages for a given Bounty application
  bountyChatSearch(input: BountyChatSearchInput!): BountyChatSearchOutput!

  # Bounty services
  bountyHunterServiceSearch(
    input: BountyHunterServiceSearchInput!
  ): BountyHunterServiceSearchOutput!

  # Find a Bounty service by ID
  bountyHunterServiceById(
    input: BountyHunterServiceByIdInput!
  ): BountyHunterServiceByIdOutput!

  # Returns a Bounty found via its URL, the username and slug
  bountyByUrl(input: BountyByUrlInput!): BountyByUrlOutput!

  # Returns existing template categories.
  templateCategories(input: TemplateCategoriesInput): TemplateCategoriesOutput

  # Return a template category via its slug
  templateCategoryBySlug(
    input: TemplateCategoryBySlugInput!
  ): TemplateCategoryBySlugOutput!

  # Replit Support Asset Upload
  supportAssetUpload(filename: String!): SupportAssetUrls!
  extensionList(includeNonBlessed: Boolean = false, userId: Int): [Extension!]!

  # Get a community-banned user by their ID
  getBannedBoardUser(userId: Int!): GetBannedBoardUserOutput
  studentsSubmissions(
    input: StudentsSubmissionsInput!
  ): StudentsSubmissionsOutput

  # Creates a URL for embedding the Tipalti Payee iFrame
  tipaltiIframeUrl: TipaltiIframeUrl!

  # Returns the Neon databases for a given user or repl
  getNeonDatabases(input: GetNeonDatabasesInput!): GetNeonDatabasesOutput!

  # Returns the available Goval continents
  replContinents: ReplContinents!

  # Get Repls that a user has permitted to use Repl Identity to authenticate as them
  allowedReplIdentityRepls: AllowedReplIdentityRepls!
  extension(id: String!): ExtensionOutput

  # Returns all extension installations for the user (and optionally scoped to a repl)
  extensionInstallationById(id: String!): ExtensionInstallationByIdOutput!

  # Returns all extension installations available to the current user in the provided repl
  extensionInstallations(replId: String!): ExtensionInstallationsOutput!

  # Preview a change to a users subscription, to see what the proration would be
  previewProration(input: PreviewProrationInput!): PreviewProrationOutput!

  # Total value value in cycles of all available bounties from a given user; if not specified, returns the total value of all available bounties.
  totalBountiesCyclesValue(userId: Int): Int!

  # Returns a list of subscription plans supported
  subscriptionPlans: SubscriptionPlansOutput!

  # Returns hosting deploy build action history.
  hostingBuildDeployActionHistory(
    input: HostingBuildDeployActionHistoryInput!
  ): HostingBuildDeployActionHistoryOutput!

  # Returns a Replit Checkout Session
  getReplitCheckoutSession(
    input: GetReplitCheckoutSessionInput!
  ): GetReplitCheckoutSessionOutput!

  # Returns whether a replit.app subdomain is available for use.
  replitAppSubdomainAvailability(
    # The subdomain for which to check availability
    subdomain: String!

    # An optional deploymentId, used to validate a subdomain for an existing deployment
    deploymentId: String
  ): ReplitAppSubdomainAvailabilityOutput!

  # Returns all the curated templates to show during onboarding
  onboardingCuratedTemplates: OnboardingTemplatesOutput!
  extensions(
    include: ExtensionInclusionType
    query: String
    order: ExtensionOrderType
    filter: ExtensionFilterType
    count: Int = 20
    after: Int
    userId: Int
  ): ExtensionsQueryOutput

  # Get information about a GitHub repository.
  githubRepoInfo(input: GitHubRepoInfoInput!): GitHubRepoInfoResult!
  hostingDeployment(id: String!): HostingDeploymentOutput

  # Creates a new GetTemplateInfo
  getTemplateInfoForFilePath(
    input: GetTemplateInfoForFilePathInput!
  ): GetTemplateInfoForFilePathOutput!
  hostingMachineConfigurations(
    input: HostingMachineConfigurationsInput!
  ): HostingMachineConfigurationsOutput!
  languageExamples(language: String): LanguageExamples!
  hostingDeploymentTemplates(
    input: HostingDeploymentTemplatesInput
  ): HostingDeploymentTemplatesResults!

  # Search for repositories
  githubRepoSearch(input: RepositorySearchInput!): GitHubRepoSearchResult!
  checkClientVersion(
    input: CheckClientVersionInput!
  ): CheckClientVersionQueryResult!
  scheduledJobListExecutions(
    input: ScheduledJobListExecutionsInput!
  ): ScheduledJobListExecutionsOutput!

  # Grab all edu team exports for a given user and team
  getEduExports(input: EduExportInputType!): GetEduExports!

  # Find a current stored org context of the user
  getUserOrgContext: Org
}

# Authenticated user
type CurrentUser {
  id: Int!
  email: String!
  username: String!
  firstName: String
  lastName: String
  locale: String!
  emailNotifications: Boolean!
  marketingNotifications: Boolean!
  isVerified: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
  displayName: String!
  fullName: String!
  url: String!
  bio: String
  location: String
  socials: [UserSocial!]!
  hasRepl: Boolean!
  hasRole(role: UserRoles!): Boolean!
  hasPrivacyRole: Boolean!
  roles(only: [UserRoles!]): [UserRole!]!
  isLoggedIn: Boolean!
  isSubscribed: Boolean!

  # Finds the user's warnings
  warnings: [Warning]
  followers(after: String, count: Int): UserConnection!
  followerCount: Int!
  follows(after: String, count: Int): UserConnection!
  followCount: Int!

  # Determines whether a user is banned from talk/canny
  isBannedFromBoards: Boolean!

  # If banned, this is the reason why they were banned.
  bannedFromBoardsReason: String

  # Determines whether a user has a hacker plan
  isHacker: Boolean!
    @deprecated(
      reason: "Use `subscriptionIsType` or `userSubscriptionType` instead"
    )

  # Checks if the user has an active subscription of the given type
  subscriptionIsType(
    # User level subscription types
    subscriptionType: UserSubscriptionTypeEnum!
  ): Boolean!

  # Returns the type of plan, if the user has a plan from the Hacker family of plans.
  userSubscriptionType: UserSubscriptionTypeEnum

  # Returns true if a user is eligible for the Pro Preview.
  isProPreviewEligible: Boolean!

  # Returns true if a user has previously enrolled in the pro preview, and now they should see the expired state.
  shouldSeeProPreviewExpiredState: Boolean!

  # Returns information about the current user subscription
  userSubscription: CurrentUserSubscriptionInfo
  gate(feature: String!): Boolean!
  allGates: [UserGate!]!
    @deprecated(reason: "No longer supported. Use currentUser.allFlags instead")
  allFlags: [Flag!]!
  flag(controlName: String!, type: UserFlagValueType): Flag!
  gateVariation(feature: String!): String
  tourSeen(name: String!): Boolean!
  toursSeen(tours: [String!]!): [TourSeen!]!

  #
  replSearch(
    search: String!

    # Only include repls owned by the user.
    excludeMultiplayer: Boolean = true

    # Only include repls that are deployed.
    excludeNotDeployed: Boolean = false

    # Only include public repls.
    excludePrivate: Boolean = false

    # Only include private repls.
    excludePublic: Boolean = false

    # Only include repls NOT owned by the user.
    excludeOwned: Boolean = false
    count: Int
  ): [Repl!]!
  paginatedReplSearch(
    search: String!

    # Only include repls owned by the user.
    excludeMultiplayer: Boolean = true

    # Only include repls that are deployed.
    excludeNotDeployed: Boolean = false

    # Only include repls NOT owned by the user.
    excludeOwned: Boolean = false

    # Only include public repls.
    excludePrivate: Boolean = false

    # Only include private repls.
    excludePublic: Boolean = false
    count: Int
    after: String
  ): ReplConnection!
  sidebarClosed: Boolean!
  search: UserSearchResults!
  hasProfileImage: Boolean!
  image: String!

  # User profile cover image
  coverImage: CoverImage
  socialSignup: Boolean!
  auth(provider: UserAuthProviders!): UserAuth
  repositories(
    count: Int!
    after: String
    privacy: RepositoryPrivacy
  ): RepositoriesOutput

  # GitHub specific information for a GitHub authed user
  gitHubInfo: GitHubInfo
  gitHubInfo2: GitHubInfo2!
  daysSinceSignup: Int!
  clui: JSON!

  # User's editor preferences
  editorPreferences: EditorPreferences!

  # User's editor preferences, represented as JSON
  workspacePreferences: JSON!

  # Finds a folder based on id
  replFolder(id: String!, teamId: Int): ReplFolder

  # Finds a folder based on path
  replFolderByPath(path: String!): ReplFolder

  # List of teams the user is a member of
  teams: [Team!]!

  # List of teams without a subscription
  freeTeams: [Team!]!
  teamOrganizations(
    # Select a type of org by subscription type
    subscriptionType: TeamOrganizationSubscriptionTypeEnum
  ): [TeamOrganization!]!

  # Teams that are connected to a Google Classroom
  googleClassroomTeams: [Team!]!

  # Finds the current user's notification count
  notificationCount: Int!

  # The current user's billing info
  billingInfo: BillingInfo

  # The current user's customer entity
  customer: Customer

  # Whether the user has authorized Replit to access their Google Classroom data
  hasGoogleClassroomScope: Boolean!

  # A list of groups of template repls or langauges
  createReplOptions: [CreateReplOptionGroup!]!

  # A list of the users favorite template repls or langauges
  favoriteCreateReplOptions: [CreateReplOptions!]!
  canCreateNewFreeTeam: Boolean!
    @deprecated(
      reason: "Creating free teams via this API is not supported anymore."
    )

  # Subscription capabilities for the user
  capabilities: SubscriptionCapabilities

  # Determines whether to show the user's presence on the site
  showPresence: Boolean!

  # Determines wether user has completed edu verification form
  showVerifyTeacherBanner: Boolean!

  # Determines wether user is currently in firewall mode or not
  isFirewallMode: Boolean!

  # Cycles state for the user
  cycles: Cycles!

  # The Goval continent of the user
  replContinent: ReplContinent!

  # Searches repls a user can publish
  publishableReplSearch(search: String!, count: Int): [Repl!]!

  # The User's active custom theme
  activeThemeVersion: ThemeVersion

  # Returns the current user's installed custom themes
  installedThemes(
    input: CurrentUserInstalledThemesInput!
  ): CurrentUserInstalledThemesOutput!

  # Returns the themes authored by the current user
  authoredThemes(
    input: CurrentUserAuthoredThemesInput!
  ): CurrentUserAuthoredThemesOutput!

  # Repl Power Ups summary
  replPowerUps: [ReplPowerUpDescriptionType!]!

  # User Power Ups summary
  userPowerUps: [UserPowerUpDescriptionType!]!
    @deprecated(reason: "Use userPowerUpsByType instead")

  # State of user-scoped Power Ups, by key
  userPowerUpsByType: UserPowerUpsTypesOutput!
  powerUpCosts: UserPowerUpCost!
    @deprecated(reason: "Use userPowerUpsByType instead")
  pricesUpdate: CurrentUserPricesUpdateOptionOutput!
    @deprecated(reason: "2022 Repricing is over")

  # Fetches a course by slug for the authed user.
  course(slug: String!): UserCourseOutput!

  # Fetches courses for the authed user.
  courses: [UserCourse!]!

  # Fetches the lesson details for the authed user, given a repl ID, if any.
  replLesson(replId: String!): UserCourseLessonOutput

  # Whether or not the user is allowed to be a Bounty solver
  canBeBountySolver: Boolean!
    @deprecated(
      reason: "No longer needed to gate access to applying - anyone can apply"
    )

  # All active Repl Power Ups for the current user
  replPowerUpsByMethodOfPayment(
    methodOfPayment: PowerUpMethodOfPayment
  ): CurrentUserReplPowerUpsByMethodOfPaymentOutput!

  # Returns information about the current user's usage-based billing consumption.
  usageBasedBilling: CurrentUserUsageBasedBillingOutput!

  # Returns information about the current user's usage-based billing consumption.
  usageInterval(input: CurrentUserUsageInput): CurrentUserUsageOutput

  # Storage information for the user
  storageInfo: StorageInfo!
  paymentMethod: UserPaymentMethod
  cyclesAutoRefillConfiguration: UserCyclesAutoRefillConfigurationOutput

  # A fast, approximate count of how many "Recent Repls" entries the user has, used to render directionally correct loading states.
  recentReplsCount(
    # Whether to retrieve the user's own Repls or Repls from multiplayer sessions (including Teams Repls)
    filter: RecentReplsFilter
  ): Int!
  signupMethod: String
  keybindings(
    environment: KeybindingsEnvironmentEnum!
    platform: KeybindingsPlatformEnum!
  ): Keybindings!
  isImpersonated: Boolean!
  preferences: JSON
  hostingDeployments(
    input: CurentUserHostingDeploymentsInput
  ): HostingDeploymentConnection!
  canAlwaysOn: Boolean!
  verifiedPhoneNumber: String

  # The current user's usage-based billing budget. Null if the user has no budget configured.
  usageBasedBillingBudget: CurrentUserUsageBasedBillingBudgetOutput

  # Returns the current user's workspace layouts
  workspaceLayouts: [UserWorkspaceLayout!]!
  canChangeUsername: Boolean!
  hasUserCompletedOnboarding: Boolean!

  # Whether or not the user needs to SMS verify to apply for a Bounty
  requiresSmsVerificationForBountyApplication: Boolean!

  # Get the list of public SSH keys for the current user
  publicSshKeys: PublicSshKeysResult!
  hasAiPro: Boolean!
  requiresActionToRedeploy: Boolean!

  # An organization to which the current user belongs.
  org(
    # The ID for which to return an org. If not provided, the user's personal org is returned.
    orgId: String
  ): CurrentUserOrgOutput!

  # Paginated list of the current user's organizations
  orgs(
    # The cursor to start the next page
    cursor: String

    # Number of items to request in a page
    count: Int
  ): CurrentUserOrgsOutput!

  # Returns the current user's filetype associations
  filetypeAssociations: JSON!
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# Social media profile links associated with a user profile
type UserSocial {
  id: Int!
  url: String!
  type: user_socialstypeEnumType!
}

enum user_socialstypeEnumType {
  twitter
  facebook
  linkedin
  github
  discord
  youtube
  twitch
  website
}

enum UserRoles {
  TEACHER
  STUDENT
  SELF_LEARNER
  ADMIN
  MODERATOR
  EXPLORER
  DETECTIVE
  TESTER
  DEVELOPER
  LANGUAGE_JAMMER
  PRIVACY_LIMITED_ACCESS
  GITHUB_CLASSROOM_USER
  TEMPLATE_DEVELOPER
  BUSINESS
  ONBOARDING_EXPERIENCE_NONE
  ONBOARDING_EXPERIENCE_LOW
  ONBOARDING_EXPERIENCE_MEDIUM
  ONBOARDING_EXPERIENCE_HIGH
  INTENT_PERSONAL
  INTENT_STUDENT
  INTENT_TEACHER
  INTENT_BUSINESS
  TEACHER_UNVERIFIED
  TEACHER_REJECTED
  REPLIT_STAFF
  FEATURED
  REPLIT_REP
  REPLIT_IDENTITY_TESTING
  DAYS_OF_CODE
  REPLIT_REP_EDU
  PATRON
  PYTHONISTA
  VERIFIED_BOUNTY_HUNTER
  EXTENSION_DEVELOPER
  AGENT_DEVELOPER
}

# A role belonging to a user
type UserRole {
  id: String!
  key: UserRoles!

  # Human readable version of the role's name
  name: String!

  # Single sentence description of the role that can be used as a tagline
  tagline: String
}

# A warning received by the user from moderators.
type Warning {
  id: Int!
  reason: String!

  # The user who received the warning.
  user: User

  # The moderator who issued the warning.
  moderator: User
  timeCreated: DateTime!
}

# A user of Replit
type User {
  id: Int!
  username: String!
  firstName: String
  lastName: String
  locale: String!
  isVerified: Boolean
  displayName: String!
  fullName: String!
  url: String!
  bio: String
  location: String
  socials: [UserSocial!]!
  hasRole(role: UserRoles!): Boolean!
  hasPrivacyRole: Boolean!
  roles(only: [UserRoles!]): [UserRole!]!
  isFollowedByCurrentUser: Boolean!
  isFollowingCurrentUser: Boolean!
  isBlockedByCurrentUser: Boolean!
  isBlockingCurrentUser: Boolean!
  isLoggedIn: Boolean!
  isSubscribed: Boolean!
  timeCreated: DateTime!

  # Finds the public repls for a user
  publicRepls(
    pinnedReplsFirst: Boolean
    showUnnamed: Boolean
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): ReplConnection! @deprecated
  followers(after: String, count: Int): UserConnection!
  followerCount: Int!
  follows(after: String, count: Int): UserConnection!
  followCount: Int!

  # Repls pinned on the profile
  pinnedRepls: [Repl!]!

  # Repls searched on the profile
  profileRepls(
    search: String
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): ReplConnection!

  # Finds the user's warnings
  warnings: [Warning]

  # Finds the user's posts
  posts(
    after: String
    count: Int
    order: String
    unlisted: Boolean
  ): PostConnection

  # Determines whether a user is banned from talk/canny
  isBannedFromBoards: Boolean!

  # Determines whether a user has a hacker plan
  isHacker: Boolean!
    @deprecated(
      reason: "Use `subscriptionIsType` or `userSubscriptionType` instead."
    )

  # Checks if the user has an active subscription of the given type
  subscriptionIsType(
    # User level subscription types
    subscriptionType: UserSubscriptionTypeEnum!
  ): Boolean!

  # Returns the type of plan, if the user has a plan from the Hacker family of plans.
  userSubscriptionType: UserSubscriptionTypeEnum
  image: String!

  # User profile cover image
  coverImage: CoverImage
  teamPermissions(teamId: Int!): TeamPermission
  redirectToTeamDashboard: Boolean!

  # Gives datetime for last time this user was seenon the site and whether they should be considered online now
  presenceStatus: UserPresenceStatus!

  # Information about a user's activity in Bounties
  bountyInfo: BountyInfo!
}

# A connection to a list of Repls.
type ReplConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Repls.
  items: [Repl!]!
}

# Information about pagination in a connection.
type PageInfo {
  # Next results available
  hasNextPage: Boolean!

  # Previous results available
  hasPreviousPage: Boolean!

  # Cursor to fetch next page
  nextCursor: String

  # Cursor to fetch previous page
  previousCursor: String
}

# A repl
type Repl {
  id: String!
  isPrivate: Boolean!
  isStarred: Boolean!
  title: String!
  slug: String!
  imageUrl: String
  folderId: String
  isRenamed: Boolean

  # The comment count for a repl
  commentCount: Int!

  # The like count for a repl
  likeCount: Int!

  # If the current has liked this repl
  currentUserDidLike: Boolean!

  # A list of groups of repls
  relatedRepls(limitPerGroup: Int): [RelatedReplsGroup!]!

  # The category of the template if the Repl is one
  templateCategory: String
    @deprecated(reason: "Deprecated in favour of repl.templateCategories field")
  languageExamples(asText: Boolean): [LanguageExample!]
    @deprecated(reason: "User legacyLanguageConfig.examples")

  # Whether or not this Repl was posted to Talk/Community
  wasPosted: Boolean!

  # Whether or not this Repl was published to Apps
  wasPublished: Boolean!
  language: String! @deprecated(reason: "Repl language is no longer supported")
  user: User
  origin: Repl

  # The icon url for a repl
  iconUrl: String!

  # The template label for a repl
  templateLabel(disableFallbackToTitle: Boolean): String!
  url(lite: Boolean): String!
  inviteUrl: String
  multiplayerInvites: [MultiplayerInvite!]!
  rootOriginReplUrl: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  isOwner: Boolean!
  config: ReplConfig!
  pinnedToProfile: Boolean!
  hostedUrl(dotty: Boolean, protocol: Protocols, dev: Boolean): String!
  nextPagePathname: String!

  # Can the requester edit the repl title, description, and public status, also if can they delete it and move it between folders
  currentUserPermissions: ReplUpdatePermissions!
  database: Database
  checkDomain2(domain: String!): CheckDomain2
  permissions: [ReplPermission!]! @deprecated(reason: "Use multiplayers field")
  template: ReplTemplate
  isProject: Boolean!
  isProjectFork: Boolean!
  isModelSolution: Boolean!
  isModelSolutionFork: Boolean!
  workspaceCta: ReplWorkspaceCta!
  submission: ReplSubmission
  annotationAnchors: [AnnotationAnchor!]!
  owner: ReplOwner
  unitTests: ReplUnitTestsWithMeta
  unitTestResults: [ReplUnitTestResultsOutput!]
  ioTests: [ReplTemplateTest!]!
  recentForks(count: Int): [Repl!]!

  # Count of public forks of this repl. Only provides an accurate count for non-template repls.
  publicForkCount: Int!

  # Number of times this repl has been run
  runCount: Int!

  # Public forks of this repl
  publicForks(after: String, count: Int, search: String): ReplConnection!
  isAlwaysOn: Boolean!
  isBoosted: Boolean!

  # A Repl's used storage
  bytesUsed: ReplBytesUsedOutput!

  # Does this repl have a GPU enabled?
  hasGpu: Boolean!

  # Deployment for this repl
  deployment: ReplDeployment

  # Releases of this repl
  releases(after: String, count: Int): ReplReleaseConnection!
  gateOnOwner(feature: String!): Boolean!

  # Tags on this repl
  tags: [Tag!]!

  # Examples of a repl
  examples: [Repl!]!

  # Results for when IO tests where executed most recently on the repl, only for edu repls.
  ioTestResults: [IOTestResult!]

  # Multiplayers of this Repl
  multiplayers: [User!]!

  # Users who have permission to collaborate on a Repl
  collaborators: [ReplCollaborator!]!

  # The language this nix template Repl is replacing
  nixedLanguage: String

  # Returns how this repl was published or null if unpublished
  publishedAs: PublishedReplKind

  # Return's a repl's source
  source: ReplSource

  # The count of all repls forked from all of this repl's releases - useful for fork counts of template repls.
  releasesForkCount: Int!

  # Return's a repl's description
  description(
    # removes Markdown formatting from text
    plainText: Boolean
  ): String

  # Information about a Repl's template. For Repls that don't have a template, returns information about the canonical language Repl
  templateInfo: ReplTemplateInfo!

  # All domains associated with this repl.
  domains: [Domain]

  # Address for the apex domain proxy for apex domain linking.
  apexProxy: String!
  replViewSettings: ReplViewSettings
  powerUpCosts: PowerUpCostsOutput!

  # State of repl-scoped Power Ups, by key
  powerUps: ReplPowerUpTypesOutput!

  # The template label for a repl
  templateReview: TemplateReview

  # The template categories for a template repl
  templateCategories: [TemplateCategory!]!

  # The Repl owner's course lesson state
  lesson: UserCourseLesson

  # When the repl was last published
  lastPublishedAt: DateTime
  hostingDeployment: ReplHostingDeployment

  # Returns the latest log lines for a hosting deployment Repl
  hostingDeploymentLogs(
    # Hosting deployment ID to filter by
    deploymentId: String!

    # Build ID to filter by
    buildId: String

    # Execution ID to filter by
    executionId: String

    # Start of log datetime range to filter by
    start: DateTime

    # End of log datetime range to filter by
    end: DateTime

    # Log message substring to filter by (currently exact match)
    message: String

    # Log level to filter by
    level: LogLevel

    # Maximum number of log lines to return
    limit: Int
  ): ReplLogsOutput!
  hostingDeploymentPermissions: ReplHostingDeploymentPermissions!
  defaultBucket: DefaultBucket

  # The top n Repl deployment analytics field values for a given time period
  analyticsTopList(input: ReplAnalyticsTopInput!): ReplAnalyticsTopListOutput!

  # The binned durations of requests to this Repl's deployment
  analyticsDuration(
    input: ReplAnalyticsDurationInput!
  ): ReplAnalyticsDurationOutput!

  # The top n Repl deployment analytics field values for a given time period
  analyticsPageViews(
    input: ReplAnalyticsPageViewsInput!
  ): ReplAnalyticsPageViewsOutput!

  # Repl deployment metric values, broken out by hour, inside of a given time period.
  analyticsTimeSeries(
    input: ReplAnalyticsTimeSeriesInput!
  ): ReplAnalyticsTimeSeriesOutput!

  # A repo
  repo: Repo

  # what the last observed normal git state of the repl was
  gitState: ReplGitInfo

  # a paginated list of repls related to this repl's git state
  relatedGitRepls(input: RelatedGitReplsInput): ReplConnection!

  # The organization that owns a Repl
  org: Org
  authorizations: ReplAuthorizations!

  # The Repl's layout for the current user and specified environment. Defaults to desktop environment if none is specified.
  layoutState(input: ReplLayoutStateInput): JSON

  # A project the Repl is linked to
  project: Project
  multiplayerStatus: ReplMultiplayerStatus!

  # Dev compute resource configurations, and whether they are available to the Repl.
  devComputeOptions: [ReplDevComputeOption!]!
}

# A group of related repls
type RelatedReplsGroup {
  # The name of the group
  name: String!

  # A list of repls
  repls: [Repl!]!
}

# Example code for a language
type LanguageExample {
  mainFile: String!
  name: String!
  code: String!
}

# An emailed invite to join Replit multiplayer
type MultiplayerInvite {
  email: String!
  replId: String!
  type: multiplayer_invitestypeEnumType!
  repl: Repl
}

enum multiplayer_invitestypeEnumType {
  r
  rw
}

type ReplConfig {
  isServer: Boolean
  isExtension: Boolean
  gitRemoteUrl: String
  domain: String @deprecated(reason: "Superseded by repl.domains")
  isVnc: Boolean
  alwaysOn: Boolean @deprecated(reason: "Superseded by repl.isAlwaysOn")
  doClone: Boolean
}

# Web protocols
enum Protocols {
  HTTPS
  WSS
}

# Allowed actions to be taken by the requesting user
type ReplUpdatePermissions {
  changeTitle: Boolean!
  changeDescription: Boolean!
  changeImageUrl: Boolean!
  changeIconUrl: Boolean!
  changeTemplateLabel: Boolean!
  changeLanguage: Boolean!
  changeConfig: Boolean!
  changePrivacy: ReplChangePrivacyPermission!
  star: Boolean!
  move: Boolean!
  delete: Boolean!
  leaveMultiplayer: Boolean!
  editMultiplayers: Boolean!
  viewHistory: Boolean!
  containerAttach: Boolean!
  containerWrite: Boolean!
  changeAlwaysOn: ReplChangeAlwaysOnPermission!
  linkDomain: Boolean!
  writeTests: Boolean!
  changeCommentSettings: Boolean!
  inviteGuests: Boolean!
  publish: Boolean!
  fork: Boolean!
  createNeonDatabase: Boolean!
}

enum ReplChangePrivacyPermission {
  Allowed
  Disallowed
  SubscriptionRequired
    @deprecated(
      reason: "We no longer use permissions as a proxy for subscription status"
    )
}

enum ReplChangeAlwaysOnPermission {
  Allowed
  Disallowed
  SubscriptionRequired
    @deprecated(
      reason: "We no longer use permissions as a proxy for subscription status"
    )
}

# A repl-specific key-value database
type Database {
  id: ID!
  jwt: String!
    @deprecated(
      reason: "Clients should no longer use a JWT to talk directly to kv.replit.com. Use sibling fields on Database instead."
    )
  keysCount: Int
  sizeMB: Float
}

union CheckDomain2 = NotFoundError | ServiceUnavailable | DomainStatus2

# An error caused by being unable to locate a resource
type NotFoundError implements Error {
  message: String!
}

interface Error {
  message: String!
}

# An error caused by a service being unavailable
type ServiceUnavailable implements Error {
  message: String!
}

# Checks if CNAME is correctly configued for a given domain to be linked.
type DomainStatus2 {
  status: String
  retry: Boolean!
  verified: Boolean!
  records: DomainStatusRecords
}

# DNS records that were obtained as part of a domain link check.
type DomainStatusRecords {
  A: [String!]
  CNAME: [String!]
  TXT: [String!]
}

# Access permissions for a repl
type ReplPermission {
  id: Int!
  userId: Int!
  replId: String!
  type: repl_permissionstypeEnumType!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  user: User
}

enum repl_permissionstypeEnumType {
  r
  rw
}

# A template for repls
type ReplTemplate {
  id: Int!
  imageUrl: String
  hoverImageUrl: String
  order: Int
  dueDate: Date
  availableStartDate: Date
  availableEndDate: Date
  isPublished: Boolean!
  isGroupProject: Boolean!
  restrictAfterSubmit: Boolean!
  allowSelfGrouping: Boolean!
  selfGroupSize: Int
  repl: Repl!
  modelSolution: ReplTemplateModelSolution
  author: User!
  tests: [ReplTemplateTest!]!
  team: Team
  url: String!

  # Returns all project submission groups. Only applies to group projects.
  submissionGroups: [ReplSubmissionGroup!]!
  submissionInfo: ReplTemplateSubmissionInfo

  # Returns the submissions the user has permission to access.
  submissions: [ReplSubmission!]!
  userSubmissionGroup: ReplSubmissionGroup
}

# A special custom Scalar type for Dates that converts to a ISO formatted string
scalar Date

# A model submission for a Repl template
type ReplTemplateModelSolution {
  id: Int!
  visibleAfterSubmitting: Boolean!
  visibleAfterDueDate: Boolean!
  visibleAfterPassingTests: Boolean!

  # Repl containing the solution files
  repl: Repl!

  # Can the current user fork the model solution. Determined by the rules of the model solution
  canStudentFork: Boolean!

  # Student fork of the model solution. Student only view the model solution via a fork.
  studentFork: Repl
}

# A test for a template repl
type ReplTemplateTest {
  id: Int!
  name: String!
  input: String!
  output: String!
  timeCreated: Date!
  type: ReplTemplateTestType!
  template: ReplTemplate!
}

enum ReplTemplateTestType {
  match
  exact
  regex
  compatibility
}

# A team inside Replit
type Team {
  id: Int!
  username: String!

  # Whether this Team has been archived
  archived: Boolean

  # Description of the team
  description: String!

  # Display name for the team
  displayName: String!

  # List of members of the team
  memberCount: Int!

  # A list of pending invites
  openInvites: [TeamInvite]!

  # Google Classroom connected to this Team
  googleClassroom: GoogleClassroom

  # List of members of the team, only visible to users in the team
  members(
    permissions: String

    # Optionally limit the number of members queried and returned.
    limit: Int
  ): [TeamMembership!]!

  # Organization that owns this team (only for paid teams)
  organization: TeamOrganization

  # Profile image for the team
  image: String!

  # Whether the user is a member of the team or not
  isMember: Boolean!

  # Whether the current user is an admin in the team or not
  isAdmin: Boolean!

  # Whether the current user is the team owner or not.
  isOwner: Boolean!

  # Whether the current user has permission to manage the team's billing or not
  hasBillingPerms: Boolean!
  inviteLink: TeamInviteLink

  # Determines if this team has privacy invites
  hasPrivacyInvites: Boolean!

  # Determines if this team has invite link with edu_signup property
  hasEduSignupInvites: Boolean!

  # Determines if this team is eligible for team templates
  hasTemplates: Boolean!

  # Visible team templates based on the requesting user's role
  templates(published: Boolean): [ReplTemplate!]!

  # Checks subscription type
  subscriptionIsType(
    # Select a type of org by subscription type
    subscriptionType: TeamSubscriptionTypeEnum
  ): Boolean!

  # Returns a stack of template repls that do not belong to any stack
  defaultTemplateStack: Stack!

  # Returns a stack of repls that do not belong to any stack
  defaultReplStack: Stack!

  # Stacks belonging to the team
  stacks: [Stack!]!

  # The template share links for the team
  templateShareLinks: [TeamTemplateShareLink!]!

  # Records of templates being shared
  templateShares: [TeamTemplateShare!]!
  url: String!

  # List of guests of the team
  guests: [TeamGuest!]!

  # Curricula that has been impored into this team
  curriculumImports: [Curriculum!]!

  # Subscription capabilities for the organization this team belongs to
  capabilities: SubscriptionCapabilities
  userPermissions: TeamUserPermissions
  followerCount: Int!
  isFollowedByCurrentUser: Boolean!
  hasGitRepositoryRepls: Boolean!
  gitRepositoryRepls: [Repl!]!
  currentUserPresenceSessions(gitRemoteUrl: String): [PresenceSession!]!
  hostingDeployments(
    input: TeamHostingDeploymentsInput
  ): TeamHostingDeploymentsOutput!
}

# An invite to a team
type TeamInvite {
  id: Int!
  accepted: Boolean!
  externalId: String

  # The team the invite belongs to
  team: Team!

  # The username for the user the invite belongs to (or their email)
  usernameOrEmail: String

  # The icon for the user the invite belongs to
  image: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Google Classroom entry point
type GoogleClassroom {
  id: Int!
  name: String!
  courseId: String!

  # Google Classroom students invites to Replit
  members: [GoogleClassroomMember]!
}

type GoogleClassroomMember {
  id: Int!
  externalId: String!
  user: User
  invite: TeamInvite
}

# A member of a team
type TeamMembership {
  id: Int!
  nickname: String
  user: User

  # The member's permissions for the team
  permissions: TeamPermission!

  # Team member email; only visible to team admin
  email: String
}

# The permissions a user has for a team
enum TeamPermission {
  admin
  member
  billing_admin
  owner
}

# Owns and manages teams
type TeamOrganization {
  id: Int!
  name: String!
  isVerified: Boolean!
  customer: Customer

  # Whether the pending verification badge is visible or not
  showVerificationBadge: Boolean!

  # Whether AI features are enabled for Repls owned by this organization's teams
  isAiEnabled: Boolean!

  # Determines if the user owns the organizaiton
  isOwner: Boolean

  # Determines if the user is an admin on the organization
  isAdmin: Boolean!

  # List of members of the org
  members: [TeamOrganizationMembership!]!
  teams: [Team!]!

  # Count of active teams belonging to this org
  teamsCount: Int
  archivedTeams: [Team!]!

  # Count of archived teams belonging to this org
  archivedTeamsCount: Int
  unsubscribedTeams: [Team!]!
  unsubscribedTeamsCount: Int

  # Subscription capabilities for the organization
  capabilities: SubscriptionCapabilities
  userPermissions: TeamOrganizationUserPermissions
  pendingInvites: [TeamOrganizationInvite!]!
  inviteLink: TeamOrganizationInviteLink
  canBeDeleted: Boolean!
  quantity: Int
  hostingDeployments(
    input: TeamOrganizationHostingDeploymentsInput
  ): TeamOrganizationHostingDeploymentsOutput!
}

# Customer billing information; all subscriptions are parented to this entity.
type Customer {
  id: Int!
  stripeCustomerId: String
  paymentMethod: customerspaymentMethodEnumType
  timeUpdated: Date
  timeCreated: Date!
  timeDeleted: Date
}

enum customerspaymentMethodEnumType {
  card
  check
  bank
}

# A member of an org
type TeamOrganizationMembership {
  id: Int!
  role: team_organization_membersroleEnumType
  user: User
}

enum team_organization_membersroleEnumType {
  team
  owner
  admin
}

# Capabilities for subscriptions and users on subscriptions
type SubscriptionCapabilities {
  isEducationPlan: Boolean!
  isBusinessPlan: Boolean!
  isPerSeatPlan: Boolean!
  canAddEducationTeam: Boolean!

  # Whether or not the current user can create an edu trial
  canCreateEduTrial: Boolean!
    @deprecated(reason: "Teams edu is being deprecated")
  isFlatPlan: Boolean!
  isExpiring(daysFromNow: Int!): Boolean!
  canCreateNewTeam: Boolean!
  canCreatePrivateRepl: Boolean!
  canViewOwnPrivateRepl: Boolean!
  availableSeats: Int!
  hasValidSubscription: Boolean!
  memberCount: Int!
  isTrial: Boolean!
}

# Organization permissions that the current user has
type TeamOrganizationUserPermissions {
  canViewOrgSettings: Boolean!
  canEditBilling: Boolean!
  canCancelPlan: Boolean!
  canDeleteOrg: Boolean!
  canLeaveOrg: Boolean!
  canAddOrgOwners: Boolean!
  canAddOrgAdmins: Boolean!
  canRemoveOrgAdmins: Boolean!
  canRemoveOrgOwners: Boolean!
  canCreateTeamsInOrg: Boolean!
  canViewTitlesOfAllTeams: Boolean!
  canViewContentsOfAllTeams: Boolean!
}

# An invite to a team organization
type TeamOrganizationInvite {
  id: Int!

  # The organization the invite belongs to
  organization: TeamOrganization!

  # Whether the invitation has been accepted or not
  accepted: Boolean!

  # The username for the user the invite belongs to (or their email)
  usernameOrEmail: String

  # The invited user
  user: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# An invite link for a team organization
type TeamOrganizationInviteLink {
  id: Int!
  code: String!
}

union TeamOrganizationHostingDeploymentsOutput =
    UnauthorizedError
  | HostingDeploymentConnection

# An error caused by a user attempting to access a resource without authorization
type UnauthorizedError implements Error {
  message: String!
}

# A connection to a list of HostingDeployments.
type HostingDeploymentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of HostingDeployments.
  items: [HostingDeployment!]!
}

# A hosting deployment for a repl, only accessible by users with write access to target Repl
type HostingDeployment {
  id: String!
  replitAppSubdomain: String
  timeCreated: Date!
  timeUpdated: Date

  # The canonical repl for this deployment
  repl: Repl!

  # The latest build attached to this deployment, for initial deployments this could be in "building" or "failed" or "success" status
  currentBuild: HostingBuild!

  # If a deployment has an actively deploying hosting build
  inProgressBuild: HostingBuild

  # The latest build status for this deployment
  latestBuildStatus: HostingBuildStatus

  # The activity logs for this deployment, for initial deployments an activity log can be of type "rollback" or "deploy"
  activityLogs(
    before: String
    after: String
    count: Int
    order: String
    direction: String
  ): HostingActivityLogConnection!

  # Custom domains linked to this hosting deployment
  domains: [HostingDeploymentDomain!]

  # Custom domains linked direclty to the repl that should be transfered or removed
  legacyReplDomains: [HostingDeploymentDomain!]
}

# A hosting build to be used in a hosting deployment, only accessible by users with write access to target Repl
type HostingBuild {
  id: String!
  description: String!
  maxMachineInstances: Int
  timeCreated: Date!
  timeUpdated: Date

  # The status of this hosting build
  status: HostingBuildStatus!

  # Whether this build's logs have expired
  hasDeployLogs: Boolean!

  # The status of this hosting build
  provider: HostingBuildProvider!

  # The machine configuration for this build
  machineConfiguration: HostingMachineConfiguration

  # The machine job for this build
  machineJob: HostingBuildMachineJob

  # The canonical repl for this deployment
  repl: Repl!

  # The user who created this build
  user: User!

  # Does the hosting build have an image tag assigned to it
  hasImageTag: Boolean!

  # The hosting builds environment variables
  envVars: [HostingBuild2EnvVar!]!
}

enum HostingBuildStatus {
  pending
  building
  running
  promoting
  failed
  success
  updating_tier
  suspending
  suspended
  resuming
}

enum HostingBuildProvider {
  goval @deprecated
  gce
  cloud_run
  static
  extension
  cron
}

# Machine configuration available for hosting deployments.
type HostingMachineConfiguration {
  id: String!
  label: String!
  slug: String!
  vcpu: String!
  memory: String!
  dedicated: Boolean!

  # The machine configuration provider.
  provider: HostingMachineConfigurationProvider!
}

enum HostingMachineConfigurationProvider {
  gce
  cloud_run
  static
}

type HostingBuildMachineJob {
  timezone: String!
  crontab: String!
  timeoutSeconds: Int
}

type HostingBuild2EnvVar {
  name: String!
  value: String!
}

# A connection to a list of HostingActivityLogs.
type HostingActivityLogConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of HostingActivityLogs.
  items: [HostingActivityLog!]!
}

# Logs of activity for a hosting deployment, only accessible by users with write access to target Repl
type HostingActivityLog {
  id: Int!
  timeCreated: Date!

  # The type of activity log
  type: HostingActivityLogType!

  # The hosting deployment associated with this activity log
  deployment: HostingDeployment!

  # The hosting build associated with this activity log
  build: HostingBuild!

  # The user who initiated the action
  user: User!
}

enum HostingActivityLogType {
  deploy
  rollback
  fail
}

# A custom domain linked to the hosting deployment
type HostingDeploymentDomain {
  id: Int!
  domain: String!
  state: HostingDeploymentDomainState!
}

enum HostingDeploymentDomainState {
  verifying
  verified
  failed
}

input TeamOrganizationHostingDeploymentsInput {
  count: Int
  after: String
}

# An invite link for a team
type TeamInviteLink {
  id: Int!
  code: String!
  eduSignup: Boolean!
}

enum TeamSubscriptionTypeEnum {
  EDUCATION
  PRO
}

# List of ordered repls
type Stack {
  id: Int!
  title: String!
  description: String

  # Number of repls in the stack
  replsCount: Int!

  # ReplTemplates that belong to the stack
  replTemplates: [ReplTemplate!]!

  # Repls that belong to the stack
  repls: [Repl!]!
}

# A link which can be used to copy templates from one team to another.
type TeamTemplateShareLink {
  id: Int!
  code: String!

  # The templates which should be copied when the link is used
  templates: [ReplTemplate!]!

  # The default stack which holds standalone templates to be copied.This value will be null if the team template share link does not contain any standalone templates
  defaultStack: LinkStack

  # The stacks which should be copied when the link is used
  stacks: [LinkStack!]!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A stack to copied when a share link is used
type LinkStack {
  # The id of the stack to be copied
  id: Int!

  # The title of the stack to be copied
  title: String

  # A list of ids of the templates within the stack to be copied
  templates: [Int!]!
}

# An instance where a body of templates were copied from one team to another.
type TeamTemplateShare {
  id: Int!

  # The team which the templates that were copied were copied from
  from: Team!

  # The team which the templates copied were copied to
  to: Team!

  # The templates which were copied
  templates: [ReplTemplate!]!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A guest of a team
type TeamGuest {
  id: Int!
  user: User
}

# Education content created for Teams
type Curriculum {
  id: Int!
  slug: String!
  title: String!
  description: String!
  coverPhotoUrl: String
  isFeatured: Boolean

  # Languages used in curriculum projects
  languages: [Language]!

  # Stacks containing the lessons as repls in. Returns the latest curriculum version; otherwise, provide a specific curriculum version.
  contents(
    # Optional version number for fetching a specific curriculum version
    versionNumber: Int
  ): CurriculumContentOutput!
}

# A Repl language
type Language {
  id: String!
  supportsMultiFiles: Boolean!
    @deprecated(reason: "all languages support multi files now")
  usesInterpreter: Boolean!
  canUseShellRunner: Boolean!
  usesTerminal2: Boolean! @deprecated(reason: "all languages use terminal2 now")
  hasUPM: Boolean!
  hasLibSearch: Boolean!
  supportsPackager3: Boolean!
  supportsGit: Boolean!
  displayName: String!
  key: String!
  category: String!
  tagline: String!
  icon: String
  engine: String
  isNew: Boolean
  isDeprecated: Boolean!
    @deprecated(
      reason: "We're migrating languages on the fly, never deprecating them"
    )
  mainFile: String!
  examples: [LanguageExample!]
  header: String
  tagName: String!
  aliases: [LanguageAlias!]
  hasReplboxWebview: Boolean!
  hasReplboxUrlBar: Boolean!
  nixTemplateRepl: Repl
  templateRepl: Repl
  betaTemplateRepl: Repl
  recentReplsCreatedCount: Int!
  hasDAP: Boolean!
  hasGit: Boolean!
}

# Example code for a language
type LanguageAlias {
  displayName: String!
  tagline: String!
  icon: String!
  category: String!
}

union CurriculumContentOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CurriculumContent

# An error caused by a user's request being bad / invalid
type UserError implements Error {
  message: String!
}

type CurriculumContent {
  versionNumber: Int!
  units: [Stack!]!
}

# Team permissions that the current user has
type TeamUserPermissions {
  canArchiveTeam: Boolean!
  canDeleteTeam: Boolean!
  canRenameTeam: Boolean!
  canLeaveTeam: Boolean!
  canAddTeamOwners: Boolean!
  canAddTeamAdmins: Boolean!
  canRemoveTeamAdmins: Boolean!
  canAddTeamMembers: Boolean!
  canRemoveTeamMembers: Boolean!
  canAddGuests: Boolean!
  canRemoveGuests: Boolean!
  canCreateTeamRepls: Boolean!
  canEditTeamRepls: Boolean!
  canDeleteTeamRepls: Boolean!
  canSubmitProjects: Boolean!
}

#
type PresenceSession {
  id: String!
  repl: Repl
  user: User
  branch: String!
  gitRemoteUrl: String!
  expiresAt: DateTime!
}

union TeamHostingDeploymentsOutput =
    UnauthorizedError
  | HostingDeploymentConnection

input TeamHostingDeploymentsInput {
  count: Int
  after: String
}

# A submission for template repls
type ReplSubmissionGroup {
  submission: ReplSubmission
  users: [User]!
}

# A submission for template repls
type ReplSubmission {
  id: Int!
  timeSubmitted: Date
  timeLastReviewed: Date
  isGroupSubmission: Boolean!
  repl: Repl
  author: User
  submissionGroup: ReplSubmissionGroup
}

type ReplTemplateSubmissionInfo {
  submittedCount: Int!
  startedCount: Int!
}

enum ReplWorkspaceCta {
  Share
  ShareUpgrade
  CreateTemplate
  PublishTemplate
  EditTemplate
  Submit
  Resubmit
  UpdateModelSolution
  ReviewSubmission
  Auth
}

# A single Annotation Anchor
type AnnotationAnchor {
  id: String!
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # Whether the annotation is resolved
  isResolved: Boolean!

  # The messages attached to the Annotation Anchor
  messages: [AnnotationMessage!]!

  # The users participating in the thread
  participants: [User!]!
  repl: Repl
  user: User

  # The number of messages in the thread
  messageCount: Int!
  unreadCount: Int!
  currentUserIsAuthor: Boolean!
  isGeneral: Boolean!
}

# A single Annotation Message
type AnnotationMessage {
  id: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  text: String! @deprecated(reason: "Superseded by content")
  content: MessageContentType!
  anchor: AnnotationAnchor
  user: User
  seen: Boolean
  currentUserIsAuthor: Boolean!
}

union MessageContentType =
    TextMessageContentType
  | StatusMessageContentType
  | PreviewMessageContentType

# A thread message containing text, usually from a user
type TextMessageContentType {
  text: String!
}

# A thread message indicating a status change.
type StatusMessageContentType {
  status: String!
}

# A thread message previewing a message. It may or may not have text.
type PreviewMessageContentType {
  preview: String
}

union ReplOwner = Team | User

# a suite of unit tests with included metadata
type ReplUnitTestsWithMeta {
  tests: [ReplUnitTest!]!
  meta: ReplUnitTestMeta
}

# A unit test for a Repl Repl
type ReplUnitTest {
  id: Int!
  name: String!
  code: String
  failureMessage: String
  repl: Repl!
  lastRun(replId: String!): ReplUnitTestLastRunOutput
}

union ReplUnitTestLastRunOutput = ReplUnitTestLastRun | UserError

type ReplUnitTestLastRun {
  status: ReplUnitTestLastRunStatus
}

enum ReplUnitTestLastRunStatus {
  PASSED
  FAILED
  NONE
}

# Metadata for a Repl unit test
type ReplUnitTestMeta {
  id: Int!
  imports: String
  initialization: String
  setup: String
  tearDown: String
}

type ReplUnitTestResultsOutput {
  id: Int!
  status: ReplUnitTestLastRunStatus
}

union ReplBytesUsedOutput =
    ServiceUnavailable
  | NotFoundError
  | UnauthorizedError
  | ReplBytesUsed

# A Repl's used storage
type ReplBytesUsed {
  # Total bytes of storage used by the Repl. Represented as a string because GiB can easily exceed int32.
  value: String!
}

# A repl deployment
type ReplDeployment {
  id: Int!
  domain: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  activeRelease: ReplRelease
}

# A Repl release
type ReplRelease {
  id: String!
  description: String!
  pending: Boolean!
  initialLayoutState: SequelizeJSON
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
  user: User

  # Returns a summary of changes between the repl's current files and this release's files.
  pendingChanges: [ReplFileChange!]!
  hostedUrl: String!
}

# The `JSON` scalar type represents raw JSON as values.
scalar SequelizeJSON

type ReplFileChange {
  fileName: String!
  changeType: ReplFileChangeType!
}

enum ReplFileChangeType {
  NewFile
  ModfiedFile
  DeletedFile
}

# A connection to a list of ReplReleases.
type ReplReleaseConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ReplReleases.
  items: [ReplRelease!]!
}

# A tag
type Tag {
  id: String!
  isOfficial: Boolean!
}

# The result of an IO test being run on a repl
type IOTestResult {
  # The output of the program when the test was executed.
  output: String!

  # The status of the test that was executed.
  status: IOTestResultStatus!

  # A unique ID for the result type
  id: ID!

  # The test which was executed to get the result
  test: IOTestResultTestType!

  # The repl which the test the result belongs to was executed on for this result.
  repl: IOTestResultReplType!
}

# The status of a result of an IO test.
enum IOTestResultStatus {
  # The IO tests passed.
  passed

  # The IO tests failed.
  failed
}

union IOTestResultTestType = NotFoundError | ReplTemplateTest

union IOTestResultReplType = NotFoundError | Repl

# A user who has permission to collaborate on a Repl
type ReplCollaborator {
  type: ReplCollaboratorType!
  permission: ReplPermissionLevel!
  userId: Int!
  user: User!
}

enum ReplCollaboratorType {
  admin
  member
  guest
}

enum ReplPermissionLevel {
  r
  rw
}

enum PublishedReplKind {
  RegularRepl
  Template
  App
}

# A source points to a specific release of a repl
type ReplSource {
  release: ReplRelease
  deployment: ReplDeployment
}

# The template info for a repl
type ReplTemplateInfo {
  replId: String
  label: String!
  iconUrl: String!
}

# A domain linked to a repl.
type Domain {
  domain: String!
  state: String!
  hosting_deployment_id: String
}

# settings related to viewing a Repl outside of the workspace
type ReplViewSettings {
  id: Int!
  defaultView: repl_view_settingsdefaultViewEnumType!
  replFile: String
  repl: Repl!
  replImage: String
}

enum repl_view_settingsdefaultViewEnumType {
  repl_file
  repl_image
}

union PowerUpCostsOutput = UnauthorizedError | NotFoundError | PowerUpCostsType

# The cost associated with various Power Ups for a given Repl
type PowerUpCostsType {
  boost: PowerUpCostDetailType!
    @deprecated(reason: "Use the boost*cpu*ram fields instead")
  alwaysOn: PowerUpCostDetailType!
  gpu: PowerUpCostDetailType!
  boost2cpu2ram: PowerUpCostDetail2Type!
  boost4cpu4ram: PowerUpCostDetail2Type!
  boost8cpu8ram: PowerUpCostDetail2Type!
  boost16cpu16ram: PowerUpCostDetail2Type!
  hostingTierE2Micro: PowerUpCostDetail2Type
  hostingTierE2Small: PowerUpCostDetail2Type
  hostingTierE2Medium: PowerUpCostDetail2Type
  hostingTierN1Custom1_4: PowerUpCostDetail2Type
  hostingTierE2Standard2: PowerUpCostDetail2Type
  hostingTierE2Standard4: PowerUpCostDetail2Type
}

# The cost associated with a given Power Up
type PowerUpCostDetailType {
  cycles: Int!
  explanation: PowerUpCostExplanationEnumType!
}

# The explanation for how a cost was set
enum PowerUpCostExplanationEnumType {
  # Requires the user to buy more cycles
  NEEDS_CYCLES

  # Requires the user to get a subscription (i.e. Hacker or Teams Pro)
  NEEDS_SUBSCRIPTION

  # Included in the user's subscription (i.e. Hacker or Teams Pro)
  INCLUDED_IN_SUBSCRIPTION

  # Included in a user or Repl's existing order
  INCLUDED_IN_EXISTING_ORDER

  # Requires the user to spend cycles
  SPEND_CYCLES

  # Requires activation an existing order
  ACTIVATE_EXISTING_ORDER

  # This product is not supported for team
  NOT_SUPPORTED_FOR_TEAMS

  # The user has reached their subscription quota and can not purchase another way
  HAS_REACHED_SUBSCRIPTION_QUOTA

  # Activating the power up will trigger Cycles auto-refill
  AUTO_REFILL
}

# The cost associated with a given Power Up
type PowerUpCostDetail2Type {
  cyclesCostNow: Int!
  cyclesCostRecurring: Int!
  methodOfPayment: PowerUpCostMethodOfPaymentEnum!
  explanation: PowerUpCostExplanationEnumType!
}

enum PowerUpCostMethodOfPaymentEnum {
  SUBSCRIPTION
  CYCLES
  INVALID
}

union ReplPowerUpTypesOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ReplPowerUpTypes

# State of user-scoped Power Ups
type ReplPowerUpTypes {
  boost: BoostPowerUpType!
  hostingTier: HostingTierPowerUpType
}

# State of the Boost Power Up
type BoostPowerUpType {
  # Resources (vCPU, RAM) provided by the Power Up
  sku: BoostSKUEnum!

  # If active, the explanation for how the Power Up was created
  methodOfPayment: PowerUpMethodOfPayment
}

enum BoostSKUEnum {
  off
  boost_8cpu_16ram
  boost_16cpu_32ram
  boost_32cpu_64ram
}

enum PowerUpMethodOfPayment {
  SUBSCRIPTION
  CYCLES
}

# State of the Hosting Tier Power Up
type HostingTierPowerUpType {
  # Hosting tier machine type (vCPU, RAM) provided by the Power Up
  sku: HostingTierPowerUpSku!

  # If active, the explanation for how the Power Up was created
  methodOfPayment: PowerUpMethodOfPayment!
}

enum HostingTierPowerUpSku {
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

# Review status of a Template
type TemplateReview {
  id: Int!
  promoted: Boolean!
  timeCreated: Date!
  timeUpdated: Date
  timeDeleted: Date
  repl: Repl
  release: ReplRelease
  deployment: ReplDeployment
  reviewedBy: User
}

# A template category.
type TemplateCategory {
  id: Int!
  title: String!
  description: String
  slug: String!
  imageUrl: String
  order: Int
  timeCreated: Date!
}

# A course lesson started by a user.
type UserCourseLesson {
  id: Int!
  lessonSlug: String!
  timeCompleted: Date
  timeCreated: Date!

  # The course under which the lesson belongs.
  course: UserCourse!

  # The forked Repl belonging to this lesson. Nullable in case the Repl is deleted.
  repl: Repl
}

# A course started by a user.
type UserCourse {
  id: Int!
  courseSlug: String!
  timeCreated: Date!

  # The course lessons the user has started.
  lessons: [UserCourseLesson!]
}

union ReplHostingDeployment = UnauthorizedError | HostingDeployment

union ReplLogsOutput = ServiceUnavailable | NotFoundError | ReplLogs

type ReplLogs {
  result: [ReplLog!]!
}

type ReplLog {
  timestamp: DateTime!
  line: String!
  executionId: String
  deploymentId: String!
  buildId: String!
  isFromReplit: Boolean
  level: LogLevel
}

enum LogLevel {
  Info
  Error
}

type ReplHostingDeploymentPermissions {
  canDeploy: Boolean!
  canDeployReservedVm: CanDeployReservedVmResult!
  canDeployAutoscale: CanDeployAutoscaleResult!
  canDeployStatic: CanDeployStaticResult!
}

type CanDeployReservedVmResult {
  isDeployable: Boolean!
  explanation: String!
}

type CanDeployAutoscaleResult {
  isDeployable: Boolean!
  explanation: String!
}

type CanDeployStaticResult {
  isDeployable: Boolean!
  deploymentCount: Int!
  limit: Int!
  explanation: String!
}

union DefaultBucket = NotFoundError | UnauthorizedError | UserError | Bucket

# A bucket in object storage
type Bucket {
  id: String!
  externalId: String!
  name: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

union ReplAnalyticsTopListOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsTopList

# A list of top Repl analytics results
type ReplAnalyticsTopList {
  results: [ReplAnalyticsTopResult!]!
}

# A metric name and value pair
type ReplAnalyticsTopResult {
  value: String!
  count: Int!
}

input ReplAnalyticsTopInput {
  # Analytics field for which we want the top results
  metric: String!

  # Localized start for the window where the want the metrics
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean

  # Number of top items to return. Defaults to 10, max 100.
  count: Int
}

union ReplAnalyticsDurationOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsDuration

# A list of binned Repl request durations
type ReplAnalyticsDuration {
  results: [ReplAnalyticsDurationResult!]!
}

# A duration bin name and value pair
type ReplAnalyticsDurationResult {
  value: String!
  count: Int!
}

input ReplAnalyticsDurationInput {
  # Localized start for the window where the want the metrics
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean
}

union ReplAnalyticsPageViewsOutput =
    NotFoundError
  | UserError
  | ReplAnalyticsPageViews

# A summary of a Repl's page views
type ReplAnalyticsPageViews {
  # The number of unique users across the reporting period.
  uniques: Int!

  # Hourly page views for the Repl
  results: [ReplAnalyticsPageViewsData!]!
}

# An hourly timestamp and the number of page views during that period.
type ReplAnalyticsPageViewsData {
  timestamp: DateTime!
  success: Int!
  failure: Int!
}

input ReplAnalyticsPageViewsInput {
  # Localized start for the window where the want the page view data.
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean
}

union ReplAnalyticsTimeSeriesOutput =
    NotFoundError
  | UserError
  | TooManyRequestsError
  | ReplAnalyticsTimeSeries

# An error caused by a user making too many requests
type TooManyRequestsError implements Error {
  message: String!
}

# Time series data for a metric across a given period.
type ReplAnalyticsTimeSeries {
  # Hourly metric data for the Repl
  results: [ReplAnalyticsTimeSeriesData!]!
}

# An hourly timestamp, the metric value, and the count of value occurrences during the period.
type ReplAnalyticsTimeSeriesData {
  timestamp: DateTime!
  value: String!
  count: Int!
  unit: String
}

input ReplAnalyticsTimeSeriesInput {
  # The metric for which we want time series data
  metric: String!

  # Localized start for the window where the want the time series data.
  start: DateTime!

  # Number of consecutive hours for which we want results. Max 168.
  hours: Int!

  # Return results for the associated deployment Repl. Defaults to false.
  deployment: Boolean
}

type Repo {
  # The ID of the repo, currently this points to a Repl
  id: String!

  # The title of the repo Repl
  title: String!
}

type ReplGitInfo {
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # the id of the repl git state is the id of the repl it is associated with
  id: String!

  # Experimental AI summary of changes in this Repl
  aiSummary: String

  # the git info for the repl
  gitInfo: JSONObject!
}

# The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSONObject

input RelatedGitReplsInput {
  # The number of repls to return. defaults to 20. max 50.
  count: Int
}

# An Organization
type Org {
  id: String!
  name: String!
  type: orgstypeEnumType!

  # Authorizations for the requesting user in the given Org.
  authorizations: OrgAuthorizations!

  # A specifc organization group.
  group(orgGroupId: String!): OrgGroupOutput!

  # A paginated list of organization groups that the requester has permission to view.
  groups(input: OrgGroupsInput): OrgGroupsOutput!

  # Returns a paginated list of deployments for the organization.
  deployments(input: OrgDeploymentsInput!): OrgDeploymentsOutput!

  # The number of organization deployments available to the viewer
  deploymentsCount: Int!

  # The organization's image
  image: String

  # Organization Member
  member(input: OrgMemberInput!): OrgMemberOutput!

  # A paginated list of organization members
  members(input: OrgMembersInput): OrgMembersOutput!

  # The number of organization members that the requester has permission to view.
  membersCount: Int!

  # Search the organization members for a match by username or email.
  memberSearch(input: OrgMemberSearchInput!): OrgMemberSearchOutput

  # The requesting user's permissions to this organization
  permissions: OrgPermissions!

  # The requesting user's recent Repls in this organization.
  recentRepls(input: OrgRecentReplsInput): ReplConnection!

  # A fast, approximate count of how many "Recent Repls" entries the user has, used to render directionally correct loading states.
  recentReplsCount: Int!

  # Search the organization members for a match by username or email.
  repls(input: OrgReplsInput!): OrgReplsOutput!

  # The number of organization Repls available to the viewer
  replsCount(input: OrgReplsCountInput): Int!

  # The number of seats in the subscription. Returns null if the user does not have permission to see this.
  seatsCount: Int

  # The slug of the organization
  slug: String!

  # Get the organizations projects available to the viewer
  projects(input: OrgProjectsInput!): OrgProjectsOutput!

  # The number of organization projects available to the viewer
  projectsCount(input: OrgProjectsCountInput!): OrgProjectsCountOutput!

  # Search the organization projects for a project
  project(input: OrgProjectInput!): OrgProjectOutput!

  # Returns information about the current user's usage-based billing consumption.
  usageInterval: OrgUsageIntervalOutput!
  paymentMethod: OrgPaymentMethod!
  planInfo: OrgPlanInfoResult!
}

enum orgstypeEnumType {
  personal
  team
  legacy_teams_edu
  legacy_teams_free
  legacy_teams_pro
}

# A collection of authorizations for an Org and the current user.
type OrgAuthorizations {
  addMember: OrgAuthorization!
  addSeat: OrgAuthorization!
  addSshKey: OrgAuthorization!
  createRepl(private: Boolean!): OrgAuthorization!
  createProject: OrgAuthorization!
  createOrgGroup: OrgAuthorization!
  deleteOrg: OrgAuthorization!
  deleteProject: OrgAuthorization!
  editBillingContact: OrgAuthorization!
  editOrgAvatar: OrgAuthorization!
  editOrgName: OrgAuthorization!
  editPaymentMethod: OrgAuthorization!
  editSubscription: OrgAuthorization!
  editUsageLimit: OrgAuthorization!
  removeMember: OrgAuthorization!
  removeSeat: OrgAuthorization!
  removeSelf: OrgAuthorization!
  removeSshKey: OrgAuthorization!
  viewBillingContact: OrgAuthorization!
  viewOrgMetadata: OrgAuthorization!
  viewPaymentMethod: OrgAuthorization!
  viewSubscription: OrgAuthorization!
  viewUsage: OrgAuthorization!
  viewUsageLimit: OrgAuthorization!
}

# An authorization result for a specific authorization check.
type OrgAuthorization {
  isAuthorized: Boolean!
  code: OrgAuthorizationCode!
  message: String!
}

enum OrgAuthorizationCode {
  authorized
  insufficient_permissions
  insufficient_quota
  requires_active_subscription
  feature_unsupported_for_non_teams
}

union OrgGroupOutput = NotFoundError | OrgGroup

# An organization group
type OrgGroup {
  id: String!
  name: String!
  type: org_groupstypeEnumType!

  # The color chosen to represent this group.
  color: OrgGroupColor!

  # A list of potential group scopes
  groupScopeOptions(
    input: OrgGroupGroupScopeOptionsInput!
  ): OrgGroupGroupScopeOptionsOutput

  # Whether the requesting user belongs to this group.
  isMember: Boolean!

  # The number of members in the group. If the user does not have permission to view group members, this value is null.
  memberCount: Int

  # A paginated list of group members
  members(input: OrgGroupMembersInput): OrgGroupMembersOutput!

  # The org scope options available to the group, from the perspective of the requesting user.
  orgScopeOptions: [OrgScopeOption!]!

  # The requesting user's permissions to the group.
  permissions: OrgGroupPermissions!

  # A list of potential Repl scopes
  replScopeOptions(
    input: OrgGroupReplScopeOptionsInput!
  ): OrgGroupReplScopeOptionsOutput

  # The group's name in kebab case.
  slug: String!
}

enum org_groupstypeEnumType {
  custom
  system_admins
  system_members
  system_guests
  system_individual
}

enum OrgGroupColor {
  grey
  red
  orange
  yellow
  lime
  blue
  purple
  pink
}

union OrgGroupGroupScopeOptionsOutput =
    UnauthorizedError
  | OrgGroupGroupScopeOptions

type OrgGroupGroupScopeOptions {
  items: [OrgGroupScopeOptions!]!
}

# A collection of scope options between a group and a target group.
type OrgGroupScopeOptions {
  targetGroupId: String!
  options: [OrgGroupScopeOption!]!
}

# A group scope option, with information about whether it is currently applied or available to be applied to an OrgGroup.
type OrgGroupScopeOption {
  groupId: String!
  role: OrgGroupOrgGroupScopeRoleOption!
  status: ScopeStatus!
}

# A role associated with a group, including none.
enum OrgGroupOrgGroupScopeRoleOption {
  restricted
  viewer
  manager
  owner
  none
}

# The status of a scope in relation to a specific group.
enum ScopeStatus {
  unavailable
  available
  current
}

input OrgGroupGroupScopeOptionsInput {
  # The group IDs for which to return possible scopes.
  groupIds: [String!]!
}

union OrgGroupMembersOutput = UserError | OrgGroupMemberConnection

# A connection to a list of OrgGroupMembers.
type OrgGroupMemberConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of OrgGroupMembers.
  items: [OrgGroupMember!]!
}

# An organization group member
type OrgGroupMember {
  id: String!
  user: User!
  lastSeen: DateTime

  # List of groups, member is part of in the given org
  groups(input: OrgMemberGroupsInput!): OrgMemberGroupsOutput!
}

union OrgMemberGroupsOutput = UserError | OrgGroupConnection

# A connection to a list of OrgGroups.
type OrgGroupConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of OrgGroups.
  items: [OrgGroup!]!
}

input OrgMemberGroupsInput {
  # Org Id of the organization
  orgId: String!

  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int
}

input OrgGroupMembersInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int
}

# An org scope option, with information about whether it is currently applied or available to be applied to an OrgGroup.
type OrgScopeOption {
  role: OrgGroupOrgScopeRole!
  status: ScopeStatus!
}

# A role associated with an organization.
enum OrgGroupOrgScopeRole {
  viewer
  editor
  deployer
  manager
  billing_manager
  owner
}

# The actions a user can perform to a specific group.
type OrgGroupPermissions {
  addMember: Boolean!
  deleteGroup: Boolean!
  editGroupColor: Boolean!
  editGroupName: Boolean!
  editPermissions: Boolean!
  removeMember: Boolean!
  removeSelf: Boolean!
  viewGroupMetadata: Boolean!
  viewMembers: Boolean!
  viewPermissions: Boolean!
  viewSelf: Boolean!
}

union OrgGroupReplScopeOptionsOutput =
    UnauthorizedError
  | OrgGroupReplScopeOptions

type OrgGroupReplScopeOptions {
  items: [ReplScopeOptions!]!
}

# A list of potential Repl scopes.
type ReplScopeOptions {
  replId: String!
  options: [ReplScopeOption!]!
}

# A Repl scope option, with information about whether it is currently applied or available to be applied to an OrgGroup.
type ReplScopeOption {
  replId: String!
  role: OrgGroupReplScopeRoleOption!
  status: ScopeStatus!
}

# A role associated with a Repl, including none.
enum OrgGroupReplScopeRoleOption {
  viewer
  editor
  deployer
  owner
  none
}

input OrgGroupReplScopeOptionsInput {
  # The Repl IDs for which to return possible scopes.
  replIds: [String!]!
}

union OrgGroupsOutput = UserError | OrgGroupConnection

input OrgGroupsInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int

  # The types of groups to return
  types: [OrgGroupType!]
}

enum OrgGroupType {
  system_admins
  system_members
  system_guests
  system_individual
  custom
}

union OrgDeploymentsOutput = UserError | HostingDeploymentConnection

input OrgDeploymentsInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int
}

union OrgMemberOutput = NotFoundError | OrgGroupMember

input OrgMemberInput {
  # Member id of the organization member
  memberId: String!
}

union OrgMembersOutput = UserError | OrgMemberConnection

# A connection to a list of OrgMembers.
type OrgMemberConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of OrgMembers.
  items: [OrgMember!]!
}

# An organization member
type OrgMember {
  # The system group to which the organization member belongs
  type: SystemOrgGroupType!

  # The member entity corresponding to that system group
  member: OrgGroupMember!
}

enum SystemOrgGroupType {
  system_admins
  system_members
  system_guests
}

input OrgMembersInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int
}

union OrgMemberSearchOutput = UserError | OrgMemberSearchResult

type OrgMemberSearchResult {
  # The member's user
  user: User!

  # If a group ID was provided in the input, where the member belongs to that group.
  isGroupMember: Boolean
}

input OrgMemberSearchInput {
  # The search input, either a username or an email address. Will not do substring matching.
  search: String!

  # An optional organization group to check a resulting member against.
  orgGroupId: String
}

# The actions a user can perform to a specific organization.
type OrgPermissions {
  addMember: Boolean!
  addSeat: Boolean!
  addSshKey: Boolean!
  createDatabase: Boolean!
  createDeployment: Boolean!
  createRepl: Boolean!
  createProject: Boolean!
  createObjectBucket: Boolean!
  createOrgGroup: Boolean!
  deleteOrg: Boolean!
  deleteProject: Boolean!
  editBillingContact: Boolean!
  editOrgAvatar: Boolean!
  editOrgName: Boolean!
  editPaymentMethod: Boolean!
  editSubscription: Boolean!
  editUsageLimit: Boolean!
  removeMember: Boolean!
  removeSeat: Boolean!
  removeSelf: Boolean!
  removeSshKey: Boolean!
  viewBillingContact: Boolean!
  viewOrgMetadata: Boolean!
  viewPaymentMethod: Boolean!
  viewSubscription: Boolean!
  viewUsage: Boolean!
  viewUsageLimit: Boolean!
}

input OrgRecentReplsInput {
  # Number of Repls to return. Maximum of 50
  count: Int = 3
}

union OrgReplsOutput = UserError | ReplConnection

input OrgReplsInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int
  filters: OrgReplsFiltersInput
}

input OrgReplsFiltersInput {
  title: TitleFilterObject
  description: DescriptionFilterObject
}

input TitleFilterObject {
  # Search by title
  search: String
}

input DescriptionFilterObject {
  # Search by description
  search: String
}

input OrgReplsCountInput {
  filters: OrgReplsFiltersInput
}

union OrgProjectsOutput = UserError | UnauthorizedError | ProjectConnection

# A connection to a list of Projects.
type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Projects.
  items: [Project!]!
}

# Projects are a collection of repls, each with a copy of the same git repository
type Project {
  id: String!
  title: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  org: Org
  mainRepl: Repl

  # The number of project Repls available to the viewer
  replsCount(input: ProjectReplsCountInput): Int!
  repls(input: ProjectReplsInput): ReplConnection!
}

input ProjectReplsCountInput {
  # Optional filters
  filters: ProjectReplsFiltersInput
}

input ProjectReplsFiltersInput {
  title: ProjectReplsTitleFilterObject
}

input ProjectReplsTitleFilterObject {
  # Search by title
  search: String
}

input ProjectReplsInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int

  # Optional filters
  filters: ProjectReplsFiltersInput
}

input OrgProjectsInput {
  # The cursor pointing to the start the next page
  cursor: String

  # Number of items to request per page
  count: Int

  # Optional filters
  filters: OrgProjectsFiltersInput
}

input OrgProjectsFiltersInput {
  title: OrgProjectsTitleFilterObject
}

input OrgProjectsTitleFilterObject {
  # Search by title
  search: String
}

union OrgProjectsCountOutput =
    UserError
  | UnauthorizedError
  | OrgProjectsCountResult

type OrgProjectsCountResult {
  count: Int!
}

input OrgProjectsCountInput {
  # Optional filters
  filters: OrgProjectsFiltersInput
}

union OrgProjectOutput = NotFoundError | UnauthorizedError | Project

input OrgProjectInput {
  projectId: String!
}

union OrgUsageIntervalOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | ServiceUnavailable
  | UsageInterval

# A user's usage-based billing usage for a given interval.
type UsageInterval {
  # Beginning of the current usage interval
  startDate: DateTime!

  # End of the current usage interval
  endDate: DateTime!

  # Total amount owed this interval in USD (after plan discount)
  totalAmountUsd: Float!

  # Subtotal amount owed this interval in USD (before plan discount)
  subtotalAmountUsd: Float!

  # Monthly discount amount in USD for the current plan
  planDiscountUsd: Float

  # Utilization of resources during this interval.
  resources: UsageIntervalResources!
}

# The usage-based billing resources used during a given interval
type UsageIntervalResources {
  # Usage of autoscale compute units during this interval
  autoscaleComputeUnits: AutoscaleComputeUnitUsage!

  # Usage of autoscale requests during this interval
  autoscaleRequests: AutoscaleRequestsUsage!

  # Usage of deployments egress during this interval
  deploymentsOutboundDataTransfer: DeploymentsOutboundDataTransferUsage!

  # Usage of development compute time during this interval
  developmentComputeTime: DevelopmentComputeTimeUsage!

  # Usage of development egress during this interval
  developmentOutboundDataTransfer: DevelopmentOutboundDataTransferUsage!

  # Usage of development storage during this interval
  developmentStorage: DevelopmentStorageUsage!

  # Usage of Modelfarm input tokens during this interval
  modelfarmInputTokens: ModelfarmInputTokensUsage!

  # Usage of Modelfarm output tokens during this interval
  modelfarmOutputTokens: ModelfarmOutputTokensUsage!

  # Usage of Neon compute time during this interval
  neonComputeTime: NeonComputeTimeUsage!

  # Usage of Neon data storage during this interval
  neonDataStorage: NeonDataStorageUsage!

  # Usage of Neon data transfer during this interval
  neonDataTransfer: NeonDataTransferUsage!

  # Usage of Neon written data during this interval
  neonWrittenData: NeonWrittenDataUsage!

  # Usage of Object Storage data storage during this interval
  objectStorageDataStorage: ObjectStorageDataStorageUsage!

  # Usage of Object Storage data transfer during this interval
  objectStorageDataTransfer: ObjectStorageDataTransferUsage!

  # Usage of Object Storage advanced operations during this interval
  objectStorageAdvancedOperations: ObjectStorageAdvancedOperationsUsage!

  # Usage of Object Storage basic operations during this interval
  objectStorageBasicOperations: ObjectStorageBasicOperationsUsage!

  # Usage of reserved VM compute time during this interval
  reservedVMComputeTime: ReservedVMComputeTimeUsage!

  # Usage of scheduled compute units during this interval
  scheduledComputeUnits: ScheduledComputeUnitUsage!

  # Usage of scheduled deployment schedulers days during this interval
  scheduledSchedulerDays: SchedulerUsage!

  # Static Deployment usage currently, not tied to any interval
  staticDeployments: StaticDeploymentUsage!
}

type AutoscaleComputeUnitUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

# A connection to a list of UnitPriceReplUsageTypes.
type UnitPriceReplUsageTypeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of UnitPriceReplUsageTypes.
  items: [UnitPriceReplUsageType!]!
}

# The amount of resources used by a Repl during a given interval.
type UnitPriceReplUsageType {
  id: String!
  repl: Repl
  usage: Float!
  percentage: Float!
}

input UsageOverviewUsageByReplInput {
  # The number of items to return in the page
  count: Int

  # Controls which page of results to fetch
  after: String
}

type AutoscaleRequestsUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type DeploymentsOutboundDataTransferUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type DevelopmentComputeTimeUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "matrix price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): MatrixPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

# A connection to a list of MatrixPriceReplUsageTypes.
type MatrixPriceReplUsageTypeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of MatrixPriceReplUsageTypes.
  items: [MatrixPriceReplUsageType!]!
}

# The amount of resources used by a Repl during a given interval.
type MatrixPriceReplUsageType {
  id: String!
  repl: Repl
  usage: Float!
  percentage: Float!
  configName: String!
}

type DevelopmentOutboundDataTransferUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type DevelopmentStorageUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ModelfarmInputTokensUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "matrix price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): MatrixPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ModelfarmOutputTokensUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "matrix price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): MatrixPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type NeonComputeTimeUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type NeonDataStorageUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type NeonDataTransferUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type NeonWrittenDataUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ObjectStorageDataStorageUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ObjectStorageDataTransferUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ObjectStorageAdvancedOperationsUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ObjectStorageBasicOperationsUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ReservedVMComputeTimeUsage {
  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "matrix price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): MatrixPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type ScheduledComputeUnitUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type SchedulerUsage {
  # The number of units for this usage-based billing resource allocated to the account for this billing interval.
  allotment: Float!

  # The number of units for this usage-based billing resource used so far during this billing interval.
  usage: Float!

  # Percentage of units of this usage-based billing resource allocated to the account used during this billing interval. A number between 0 and 1, and can have numbers over 1 that represents you have gone over your quota.
  percentage: Float

  # Overage costs in USD for this usage-based billing resource for this billing interval.
  overageCostsUSD: Float

  # The total number of repls that have used this usage-based billing resource for this billing interval.
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): UnitPriceReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

type StaticDeploymentUsage {
  allotment: Int!
  usage: Int!
  percentage: Float!
  overageCostsUSD: Int!
  totalRepls: Int!

  # Usage for an Orb "unit price" resource, grouped by Repl, for this billing interval. This currently has as hard coded maximum of 10 Repls to return.
  usageByReplConnection(
    input: UsageOverviewUsageByReplInput
  ): StaticDeploymentReplUsageTypeConnection!
  unitPrice: String
  displayName: String!
}

# A connection to a list of StaticDeploymentReplUsageTypes.
type StaticDeploymentReplUsageTypeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of StaticDeploymentReplUsageTypes.
  items: [StaticDeploymentReplUsageType!]!
}

# The amount of resources used by a Repl during a given interval.
type StaticDeploymentReplUsageType {
  id: String!
  repl: Repl
  usage: Int!
  percentage: Float!
}

union OrgPaymentMethod = UnauthorizedError | NotFoundError | PaymentMethod

# A payment method
type PaymentMethod {
  # The ID of the payment method
  id: Int!

  # The last 4 digits of the card
  last4: Int!

  # The month the card expires
  expirationMonth: Int!

  # The year the card expires
  expirationYear: Int!

  # The ID of the payment method in the payment provider
  externalId: String!

  # Whether the payment method has been saved in our database. If false, this is a candidate card that has not been saved yet.
  isSaved: Boolean!
}

union OrgPlanInfoResult = UnauthorizedError | NotFoundError | OrgPlanInfo

# Information about the org's plan, if it exitsts.
type OrgPlanInfo {
  # The cost per seat in dollars
  perSeatCost: Float!

  # The name of the plan.
  name: String!

  # The email associated with the orb subscription.
  email: String!
}

# A collection of authorizations for a Repl and the current user.
type ReplAuthorizations {
  addCustomDomain: ReplAuthorization!
  connectToWorkspace: ReplAuthorization!
  connectUsingSsh: ReplAuthorization!
  createDatabase: ReplAuthorization!
  createDeployment(provider: HostingBuildProvider!): ReplAuthorization!
  createObjectBucket: ReplAuthorization!
  createObjectStorageObject: ReplAuthorization!
  deleteCustomDomain: ReplAuthorization!
  deleteDatabase: ReplAuthorization!
  deleteDeployment: ReplAuthorization!
  deleteObjectBucket: ReplAuthorization!
  deleteObjectStorageObject: ReplAuthorization!
  deleteRepl: ReplAuthorization!
  editDeploymentSecrets: ReplAuthorization!
  editDeploymentStatus(provider: HostingBuildProvider!): ReplAuthorization!
  editDeploymentTier(provider: HostingBuildProvider!): ReplAuthorization!
  editFileContents: ReplAuthorization!
  editFolder: ReplAuthorization!
  editMetadata: ReplAuthorization!
  editObjectStorageObject: ReplAuthorization!
  editPermissions: ReplAuthorization!
  editResources: ReplAuthorization!
  editSecrets: ReplAuthorization!
  editTemplateMetadata: ReplAuthorization!
  editVisibility: ReplAuthorization!
  fork(input: ReplAuthorizationForkInput): ReplAuthorization!
  inviteGuests: ReplAuthorization!
  publish: ReplAuthorization!
  redeployDeployment(provider: HostingBuildProvider!): ReplAuthorization!
  removeSelf: ReplAuthorization!
  star: ReplAuthorization!
  viewDatabase: ReplAuthorization!
  viewDeploymentAnalytics: ReplAuthorization!
  viewDeploymentConfig: ReplAuthorization!
  viewDeploymentLogs: ReplAuthorization!
  viewFileContents: ReplAuthorization!
  viewMetadata: ReplAuthorization!
  viewObjectStorageObjects: ReplAuthorization!
  viewPermissions: ReplAuthorization!
  writeTests: ReplAuthorization!
}

# An authorization result for a specific authorization check.
type ReplAuthorization {
  isAuthorized: Boolean!
  code: ReplAuthorizationCode!
  message: String!
}

enum ReplAuthorizationCode {
  authorized
  authorized_quota
  insufficient_budget
  insufficient_permissions
  insufficient_quota
  feature_unsupported_for_replit_teams
  feature_unsupported_for_teams_edu
  feature_unsupported_for_teams_pro
  feature_unsupported_for_teams_free
  requires_active_subscription
  requires_email_verification
  requires_sms_verification
  requires_payment_method
  requires_payment_method_or_subscription
  requires_unbanning
}

# An authorization result for a specific authorization check.
input ReplAuthorizationForkInput {
  destinationOrgId: String
  isPrivate: Boolean
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

input ReplLayoutStateInput {
  # The environment to retrive the layout state for
  environment: LayoutStateEnvironmentEnum
}

enum LayoutStateEnvironmentEnum {
  desktop
  mobile
}

type ReplMultiplayerStatus {
  groups: [ReplMultiplayerGroupScope!]!
  individuals: [ReplMultiplayerIndividualScope!]!
}

type ReplMultiplayerGroupScope {
  group: OrgGroup!
  options: [ReplScopeOption!]!
}

type ReplMultiplayerIndividualScope {
  group: OrgGroup!
  user: User!
  options: [ReplScopeOption!]!
}

type ReplDevComputeOption {
  sku: ReplDevComputeSku!
  status: ReplDevComputeOptionStatus!
  cost: String!
  displayName: String!
  description: String!
}

enum ReplDevComputeSku {
  boost_4cpu_8ram
  boost_8cpu_16ram
  boost_16cpu_32ram
  boost_32cpu_64ram
}

enum ReplDevComputeOptionStatus {
  current
  available
  unavailable
}

# A connection to a list of Users.
type UserConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Users.
  items: [User!]!
}

# A connection to a list of Posts.
type PostConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Posts.
  items: [Post!]!
}

# A board to post repls to
type Post {
  id: Int!
  title: String
  showHosted: Boolean
  voteCount: Int!
  commentCount: Int!
  isPinned: Boolean
  isHidden: Boolean!
  isLocked: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
  body: String!
  url: String!
  user: User
  board: Board
  repl: Repl
  isAnnouncement: Boolean!
  canEdit: Boolean!
  canComment: Boolean!
  canPin: Boolean!
  canHide: Boolean!
  canChangeBoard: Boolean!
  canReport: Boolean!
  hasReported: Boolean!
  preview(length: Int, removeMarkdown: Boolean): String!
}

# A board to post repls to
type Board {
  id: Int!
  name: String!
  description: String
  slug: String!
  cta: String
  titleCta: String
  bodyCta: String
  template: String
  buttonCta: String
  color: String
  replRequired: Boolean!
  isLocked: Boolean!
  isAnswerable: Boolean!
  isPrivate: Boolean!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  url: String!
  canPost: Boolean!
}

enum UserSubscriptionTypeEnum {
  HACKER
  HACKER_PRO
}

type CoverImage {
  url: String!
  offsetY: Int!
}

type UserPresenceStatus {
  # Datetime for last time this user was seen on the site
  lastSeen: DateTime

  # Whether the user should be considered online
  isOnline: Boolean!
}

# Information about a user's activity in Bounties
type BountyInfo {
  # Stats about a user's activity in Bounties
  stats: BountyUserStats!

  # Bounty reviews for a given user
  hunterReviews(after: String, count: Int): BountyHunterReviewsOutput!

  # How much a user has earned in Cycles
  hunterEarnings: BountyHunterEarnings!

  # How much a user has spent on Bounties in Cycles
  posterSpending: BountyPosterSpending!
}

# Bounty-related stats for a user
type BountyUserStats {
  completedBountiesCount: Int!
  inProgressBountiesCount: Int!
  postedBountiesCount: Int!
  numHunterReviews: Int!
  averageHunterRating: Float!
}

union BountyHunterReviewsOutput =
    UserError
  | UnauthorizedError
  | BountyHunterReviewConnection

# A connection to a list of BountyHunterReviews.
type BountyHunterReviewConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyHunterReviews.
  items: [BountyHunterReview!]!
}

# A review of a Bounty hunter by a Bounty Poster
type BountyHunterReview {
  id: Int!
  communicationRating: Int!
  qualityRating: Int!
  timelinessRating: Int!
  reviewText: String
  bounty: Bounty
  reviewedUser: User
  reviewingUser: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Represents a request for work in exchange for cycles
type Bounty {
  id: Int!
  title: String!
  slug: String!
  description: String!
  cycles: Int!
  deadline: Date!
  status: bountiesstatusEnumType!
  isUnlisted: Boolean!
  timeCreated: Date!

  # A preview of the Bounty's description with all markdown syntax stripped away
  descriptionPreview: String!
  solverPayout: Int!
  fee: Int!
  isCurrentUserBountyPoster: Boolean!
  isCurrentUserBountySolver: Boolean!
  hasCurrentUserApplied: Boolean!

  # The current user application for this bounty, if it exists
  currentUserApplication: BountyApplication
  canCurrentUserCancel: Boolean!
  user: User
  solver: User

  # If it exists, review of the hunter for completing this Bounty
  bountyHunterReview: BountyHunterReview
  walletId: String
  contactInfo: String
  contactMethod: BountyContactMethod
  acceptedApplication: BountyApplication

  # Count of applications that are publicly visible (i.e. those not awaiting moderation)
  applicationCount: Int!
  latestSubmission: BountySubmission
  submissions: [BountySubmission!]!
  events(count: Int, after: String): BountyEventConnection
}

enum bountiesstatusEnumType {
  open
  in_progress
  completed
  canceled
}

# Represents an application to work on a Bounty
type BountyApplication {
  id: Int!
  content: String!
  status: bounty_applicationsstatusEnumType!
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # The applicant's contact info, which is only viewable by the Bounty poster and the applicant
  contactInfo: String

  # The Bounty that this application is for
  bounty: Bounty

  # The user who created this application
  user: User

  # True if the current user is the user who created this application
  isCurrentUserApplicant: Boolean!

  # True if the current user can remove this application
  canCurrentUserRemoveApplication: Boolean!

  # True if the current user can send a chat message, false otherwise
  canCurrentUserSendChatMessage: Boolean!

  # True if the current user can view the chat for this bounty application
  canCurrentUserViewChat: Boolean!

  # The number of unread chat messages for this bounty application
  unreadChatMessageCount: Int!
}

enum bounty_applicationsstatusEnumType {
  accepted
  rejected
  not_reviewed
  awaiting_moderation
}

enum BountyContactMethod {
  email
  discord
}

# Represents a submission for a Bounty
type BountySubmission {
  id: Int!
  content: String!
  bounty: Bounty
  repls: [Repl!]!
  review: BountySubmissionReview
  user: User
}

# Represents a review of a Bounty submission
type BountySubmissionReview {
  id: Int!
  isAccepted: Boolean!
  content: String
  submission: BountySubmission
}

# A connection to a list of BountyEvents.
type BountyEventConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyEvents.
  items: [BountyEvent!]!
}

# Represents an event that happened to a Bounty
union BountyEvent =
    BountyApplicationReviewedEvent
  | BountyStateChangeEvent
  | BountyWorkReviewedEvent
  | BountyWorkSubmittedEvent
  | BountyUpdatesEvent
  | BasicBountyEvent

# An event for when a bounty application is reviewed. currently only fired when application is accepted
type BountyApplicationReviewedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  user: User
  isAccepted: Boolean!
}

enum bounty_eventseventTypeEnumType {
  application_submitted
  application_reviewed
  work_submitted
  work_reviewed
  bounty_updated
  bounty_abandoned
  bounty_canceled
  bounty_state_change
}

# Represents a bounty changing between open, in progress, closed
type BountyStateChangeEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty

  # null if this is the first state change (bounty opened)
  oldStatus: String
  newStatus: String!
}

# Represents a bounty submission being reviewed
type BountyWorkReviewedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  content: String!
  isAccepted: Boolean!
}

# Represents someone submitting work for a bounty
type BountyWorkSubmittedEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  user: User
  content: String!
  repls: [Repl!]!
  bountySubmission: BountySubmission
    @deprecated(
      reason: "use event field directly instead of querying this type"
    )
}

# Represents an update to a bounty
type BountyUpdatesEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
  bounty: Bounty
  before: BountyUpdate!
  after: BountyUpdate!
}

type BountyUpdate {
  title: String!
  description: String!
  cycles: Int!
  deadline: Date!
  contactInfo: String
}

# Represents a bounty event
type BasicBountyEvent {
  id: Int!
  eventType: bounty_eventseventTypeEnumType!
  timeCreated: Date!
}

type BountyHunterEarnings {
  # Approximate earnings in Cycles
  approximateCyclesEarned: Int!
}

type BountyPosterSpending {
  # Approximate amount spent on Bounties in Cycles
  approximateCyclesSpent: Int!
}

# information about the current user's subscription
type CurrentUserSubscriptionInfo {
  # Returns true if a user is on a trial plan, false otherwise
  isTrial: Boolean!

  # Returns the date the user's current trial expires, or null
  timeRemainingInTrial: DateTime
}

# A user gate (feature flag).
type UserGate {
  type: UserGateValueType!
  controlName: String!
  value: StringNumberBoolean!
}

enum UserGateValueType {
  boolean
  string
  number
  json
}

# A type that can be a string, number, or boolean
scalar StringNumberBoolean

# A feature flag
type Flag {
  id: String!
  type: UserFlagValueType!
  value: FlagValueType!
}

enum UserFlagValueType {
  boolean
  string
  number
  json
}

# The type that a feature flag can assume; at the moment: string, number, or boolean
scalar FlagValueType

# A tour and its seen status
type TourSeen {
  id: String!
  seen: Boolean!
}

# Grouped Search results for authenticated user
type UserSearchResults {
  repls(query: String, count: Int): [Repl!]!
  posts(query: String, count: Int): [Post!]! @deprecated
  languages(query: String, count: Int): [Language!]! @deprecated
}

# An object for keeping user auth from different providers
type UserAuth {
  accessToken: String
  provider: UserAuthProviders!
}

enum UserAuthProviders {
  GOOGLE
  GITHUB
  FACEBOOK
  APPLE
}

# Possible results when querying currentUser.repositories
union RepositoriesOutput = RepositoryConnection | UserAuthProviderError

# A connection to a list of Repositorys.
type RepositoryConnection {
  # Number of repostories requested per installation
  count: Int

  # A list of Repositorys.
  items: [Repository!]!
}

# A user repository
type Repository {
  id: String!
  provider: String!
  name: String!
  nameWithOwner: String!
  ownerName: String!
  gitUrl: String!
  url: String!
  isPrivate: Boolean!
  createdAt: String!
  updatedAt: String!
  description: String
  primaryLanguage: GitHubLanguage
  starCount: Int!
  repls: [Repl!]

  # The most recently created Repl for this repository
  repl: Repl
}

# A GitHub language
type GitHubLanguage {
  id: String!
  name: String!
  color: String
}

# A user auth provider error
type UserAuthProviderError {
  provider: UserAuthProviders!
  message: String!
}

enum RepositoryPrivacy {
  PRIVATE
  PUBLIC
}

type GitHubInfo {
  accessToken: String

  # Indicates if the currentUser has any valid GH app installation. A true value indicates that we have app permissions to run GH API calls on some resource the user has access to. See getCurrentUserAppInstallations docs for more information, but a user can have zero or more app installations.
  isAppCurrentlyInstalled: Boolean!
  installations: [GitHubUserInstallations!]
  userInfo: GitHubUserInfo
}

type GitHubUserInstallations {
  # The installation ID
  id: Int!
  type: String!
  avatarUrl: String
  name: String!

  # The ID of the account the installation is for
  accountId: Int!

  # Whether all repositories have been selected or there's a selection involved. When 'all', it indicates the user has given us access to all of their repositories.
  repositorySelection: GitHubAppInstallationRepositorySelection!
}

enum GitHubAppInstallationRepositorySelection {
  ALL
  SELECTED
}

type GitHubUserInfo {
  name: String
  username: String
  email: String
  avatarUrl: String
}

type GitHubInfo2 {
  isConnected: Boolean!
}

# A user's editor preferences
type EditorPreferences {
  isLayoutStacked: Boolean!
  theme: String!
  fontSize: Int!
  mobileFontSize: Int!
  acceptSuggestionOnCommitCharacter: Boolean!
  indentIsSpaces: Boolean!
  indentSize: Int!
  indentDetection: Boolean!
  indentFormatPastes: Boolean!
  keyboardHandler: String
  wrapping: Boolean!
  mobileWrapping: Boolean!
  codeIntelligence: Boolean!
  semanticTokens: Boolean!
  codeSuggestion: Boolean!
  completeCodeEngine: String
  chatAudioNotification: Boolean!
  chatEngine: String
  ghostwriterUseAdvancedModel: Boolean!
  ghostwriterChatServiceEnvironment: String
  accessibleTerminal: Boolean!
  shellBellAudio: Boolean!
  multiselectModifierKey: String!
  webviewAutoOpenOnPortOpened: Boolean!
  forwardPortsAutomatically: String!
  formatOnSave: Boolean!
  extraDelight: Boolean!
  enableGpu: Boolean!
  minimapDisplay: String!
  rulers: [Int!]!
  showLeadingWhitespace: Boolean!
  showEnclosedWhitespace: Boolean!
  showTrailingWhitespace: Boolean!
  showSelectedWhitespace: Boolean!
  showFileTreeGitStatus: Boolean!
  outputUpdateTrigger: String
}

# A folder of repls
type ReplFolder {
  id: String!
  userId: Int
  name: String!
  parentId: String
  timeCreated: DateTime!
  timeUpdated: DateTime!
  path: String!
  pathnames: [String!]!
  canEdit: Boolean!
  canCreateSubFolders: Boolean!
  replsCount: Int
  parent: ReplFolder
  image: String
  folderType: ReplFolderTypes
  folders(search: String): [ReplFolder!]!
  repls(
    count: Int
    order: String
    after: String
    starred: Boolean
  ): ReplConnection!
}

enum ReplFolderTypes {
  MULTIPLAYER
  TEAM
  ALL_TEAMS
  VIRTUAL
  DEFAULT
}

enum TeamOrganizationSubscriptionTypeEnum {
  EDUCATION
  PRO
}

# A user's billing info
type BillingInfo {
  planInfo: PlanInfo
  expiration: DateTime
}

type PlanInfo {
  provider: PaymentProviderEnum!

  # The subscription id or sku that correlates only with Google Play Store plans
  googleSubscriptionId: String

  # The unit amount in cents to be charged, represented as a whole integer if possible
  amount: Int
  nextPaymentDue: DateTime
  description: String!
  interval: String
  cancelAt: DateTime
  coupon: DiscountInfo
}

enum PaymentProviderEnum {
  stripe
  apple
  google
}

type DiscountInfo {
  amount: Int
  percent: Int
  endAt: DateTime
}

# A group of template repls or languages
type CreateReplOptionGroup {
  # The name of the group
  name: String!

  # A list of template repls or languages
  options: [CreateReplOptions!]!
}

union CreateReplOptions = Language | Repl

# Information about Cycles related entities for the current user
type Cycles {
  # True if the user has a Cycles subscription
  hasSubscription: Boolean!
    @deprecated(
      reason: "All users have been migrated to Auto-refill, Cycles subscriptions are no longer used"
    )

  # The user's active Cycles Subscription, if they have one
  subscription: CurrentUserActiveCyclesSubscription
    @deprecated(
      reason: "All users have been migrated to Auto-refill, Cycles subscriptions are no longer used"
    )

  # Cycles balance
  balance: CyclesBalanceOutput!

  # Paginated transactions for the current user
  transactions(after: String, count: Int): CyclesTransactionConnection

  # Forecasts for a user's cycles
  forecast(
    # Days from current time to calculate the forecast
    daysFromNow: Int!
  ): CyclesForecastOutput!
    @deprecated(
      reason: "cycles are no longer used for power ups. removed the test for this already"
    )
}

union CurrentUserActiveCyclesSubscription = NotFoundError | CyclesSubscription

# A user's subscription for recurring Cycles purchases
type CyclesSubscription {
  id: Int!
  cycles: Int!

  # The next time the subscription will be fulfilled if the subscription is active
  nextRefillDate: DateTime
    @deprecated(
      reason: "All users have been migrated to Auto-refill, Cycles subscriptions are no longer used"
    )
}

union CyclesBalanceOutput =
    UnauthorizedError
  | ServiceUnavailable
  | CyclesBalance

type CyclesBalance {
  cycles: Float!
  lastUpdated: DateTime!
}

# A connection to a list of CyclesTransactions.
type CyclesTransactionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of CyclesTransactions.
  items: [CyclesTransaction!]!
}

type CyclesTransaction {
  # Transaction ID
  id: String!

  # User ID for the party whose balance is affected by the transaction
  principal_user_id: Int!

  # Number of cycles
  cycles: Int!

  # The type of transaction (e.g. purchased, granted, retired, redeemed)
  type: CyclesTransactionTypeEnumType!

  # When the transaction was created
  time_created: DateTime

  # Contextual information about the transaction: transaction group, assosciated repl, database table
  metadata: Metadata

  # Category the transaction falls under
  category: CategoryEnumType

  # What the transaction is used for on the product
  category_sub_type: CategorySubTypeEnumType
}

enum CyclesTransactionTypeEnumType {
  purchased
  granted
  redeemed
  retired
  transferred
  fee_charged
  cashed_out
  earned
}

type Metadata {
  system: MetadataSystemEnumType
  relation: MetadataRelationEnumType
}

enum MetadataSystemEnumType {
  web_postgres
}

enum MetadataRelationEnumType {
  bounties
  external_transactions
  repl_order
  user_order
  tips
}

enum CategoryEnumType {
  marketplace
  uncategorized
  credits
  earnings
  adjustments
  power_ups
}

enum CategorySubTypeEnumType {
  bounty
  transferred
  purchased
  granted
  redeemed
  retired
  earned
  fee_charged
  cashed_out
  uncategorized
  boost
  always_on
  ghostwriter
  private_repl
  gpu
  tips
  egress
  hosting_tier
  storage
}

union CyclesForecastOutput =
    UserError
  | UnauthorizedError
  | ServiceUnavailable
  | CyclesForecast

type CyclesForecast {
  # Indicates if the user's current Cycles balance is enough to fulfill their currently active Power Ups up to and including the specified date
  hasSufficientCycles: Boolean!

  # The amount of Cycles that would be spent according to the forecast
  estimatedCyclesSpend: Int!
}

type ReplContinent {
  # The continent's name
  name: String!

  # The continent ID
  id: ReplContinentId!
}

enum ReplContinentId {
  NA
  ASIA
}

# A version of a custom theme
type ThemeVersion {
  id: Int!
  saturation: Float!
  lightness: Float!
  description: String!
  timeUpdated: DateTime!
  hue: Float
  customTheme: CustomTheme!
  values: ThemeValues!
}

# The root type for a custom theme
type CustomTheme {
  id: Int!
  title: String!
  slug: String!

  # The URL for a given theme. Useful for linking to the cover page for that theme. Returns null if the author was deleted or banned.
  url: String

  # The URL for a given theme's edit page. Returns null if the author was deleted or banned.
  editPageUrl: String
  latestThemeVersion: ThemeVersion
  draftThemeVersion: ThemeVersion
  author: User
  colorScheme: CustomThemeColorScheme!
  status: CustomThemeStatus!

  # The number of users that have installed the theme.
  numInstalls: Int!

  # Whether the custom theme has unpublished changes. This field will always resolve to false if the current user is not the theme author
  hasUnpublishedChanges: Boolean!

  # Whether current user is author of the theme
  isCurrentUserThemeAuthor: Boolean!

  # Whether current user has the theme installed. It is important to note that a Theme is considered installed if the current user is the theme author even though there is no InstalledThemes entry.
  isInstalledByCurrentUser: Boolean!

  # Whether current user has the theme installed and can upgrade to a new version of the theme. This will always be false for theme authors because they are always on the latest version. This will also be false for users without the theme installed.
  canCurrentUserInstallUpdate: Boolean!

  # Returns the version of a theme that the current user has installed, or null if the theme is not installed by the current user. If the user is the author, they will get the draft version if one exists, or the latest release version.
  currentUserInstalledThemeVersion: ThemeVersion
}

enum CustomThemeColorScheme {
  light
  dark
}

enum CustomThemeStatus {
  hidden
  public
  deleted
}

# The values from a customTheme
type ThemeValues {
  global: ThemeValuesGlobal!
  editor: ThemeValuesEditor!
}

# The global Theme values
type ThemeValuesGlobal {
  backgroundRoot: String!
  backgroundDefault: String!
  backgroundHigher: String!
  backgroundHighest: String!
  backgroundOverlay: String!
  foregroundDefault: String!
  foregroundDimmer: String!
  foregroundDimmest: String!
  outlineDimmest: String!
  outlineDimmer: String!
  outlineDefault: String!
  outlineStronger: String!
  outlineStrongest: String!
  accentPrimaryDimmest: String!
  accentPrimaryDimmer: String!
  accentPrimaryDefault: String!
  accentPrimaryStronger: String!
  accentPrimaryStrongest: String!
  accentPositiveDimmest: String!
  accentPositiveDimmer: String!
  accentPositiveDefault: String!
  accentPositiveStronger: String!
  accentPositiveStrongest: String!
  accentNegativeDimmest: String!
  accentNegativeDimmer: String!
  accentNegativeDefault: String!
  accentNegativeStronger: String!
  accentNegativeStrongest: String!
  redDimmest: String!
  redDimmer: String!
  redDefault: String!
  redStronger: String!
  redStrongest: String!
  orangeDimmest: String!
  orangeDimmer: String!
  orangeDefault: String!
  orangeStronger: String!
  orangeStrongest: String!
  yellowDimmest: String!
  yellowDimmer: String!
  yellowDefault: String!
  yellowStronger: String!
  yellowStrongest: String!
  limeDimmest: String!
  limeDimmer: String!
  limeDefault: String!
  limeStronger: String!
  limeStrongest: String!
  greenDimmest: String!
  greenDimmer: String!
  greenDefault: String!
  greenStronger: String!
  greenStrongest: String!
  tealDimmest: String!
  tealDimmer: String!
  tealDefault: String!
  tealStronger: String!
  tealStrongest: String!
  blueDimmest: String!
  blueDimmer: String!
  blueDefault: String!
  blueStronger: String!
  blueStrongest: String!
  blurpleDimmest: String!
  blurpleDimmer: String!
  blurpleDefault: String!
  blurpleStronger: String!
  blurpleStrongest: String!
  purpleDimmest: String!
  purpleDimmer: String!
  purpleDefault: String!
  purpleStronger: String!
  purpleStrongest: String!
  magentaDimmest: String!
  magentaDimmer: String!
  magentaDefault: String!
  magentaStronger: String!
  magentaStrongest: String!
  pinkDimmest: String!
  pinkDimmer: String!
  pinkDefault: String!
  pinkStronger: String!
  pinkStrongest: String!
  greyDimmest: String!
  greyDimmer: String!
  greyDefault: String!
  greyStronger: String!
  greyStrongest: String!
  brownDimmest: String!
  brownDimmer: String!
  brownDefault: String!
  brownStronger: String!
  brownStrongest: String!
  black: String!
  white: String!
}

# The editor Theme values
type ThemeValuesEditor {
  syntaxHighlighting: [ThemeEditorSyntaxHighlighting!]!
}

# An object which contains CSS styles that are applied to a given set of editor tags
type ThemeEditorSyntaxHighlighting {
  tags: [ThemeEditorTag!]!
  values: JSON!
}

# A selector for a given editor tag
type ThemeEditorTag {
  name: String!
  modifiers: [String!]
}

union CurrentUserInstalledThemesOutput =
    UserError
  | UnauthorizedError
  | InstalledThemeConnection

# A connection to a list of InstalledThemes.
type InstalledThemeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of InstalledThemes.
  items: [InstalledTheme!]!
}

# The root type for an installed theme
type InstalledTheme {
  id: Int!
  user: User!
  themeVersion: ThemeVersion!
  customTheme: CustomTheme!
}

# Input for the current user installed themes query. If passed in, after must be a string representing a valid positive integer and count must be an integer between 0 and 100
input CurrentUserInstalledThemesInput {
  after: String
  count: Int
}

union CurrentUserAuthoredThemesOutput =
    UserError
  | UnauthorizedError
  | CustomThemeConnection

# A connection to a list of CustomThemes.
type CustomThemeConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of CustomThemes.
  items: [CustomTheme!]!
}

# Input for the current user authored themes query. If passed in, after must be a string representing a valid positive integer and count must be an integer between 0 and 100
input CurrentUserAuthoredThemesInput {
  after: String
  count: Int
}

type ReplPowerUpDescriptionType {
  # Power Up ID
  id: Int!

  # The Repl to which the Power Up relates
  repl: Repl!

  # Whether the Power Up is active
  active: Boolean!

  # The type of Power Up (e.g. boost, always on, private)
  type: ReplPowerUpTypeEnumType!

  # The SKU of the Power Up
  sku: ReplPowerUpSkuEnumType!

  # When the Power Up was last fulfilled
  time_last_fulfilled: DateTime

  # When the Power Up will be fulfilled next
  time_fulfillment_due: DateTime
}

enum ReplPowerUpTypeEnumType {
  alwaysOn
  boost
  gpu
  hosting_tier
}

enum ReplPowerUpSkuEnumType {
  alwaysOn_legacy
  alwaysOn
  boost_legacy
  gpu_k80
  boost_2cpu_2ram
  boost_4cpu_4ram
  boost_8cpu_8ram
  boost_16cpu_16ram
  unknown
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

# Power Ups which relate to the user (as-compared-with repl-specific Power Ups)
type UserPowerUpDescriptionType {
  # Power Up ID
  id: Int!

  # Whether the Power Up is active
  active: Boolean!

  # The type of Power Up
  type: UserPowerUpTypeEnumType!

  # When the Power Up was last fulfilled
  time_last_fulfilled: DateTime

  # When the Power Up will be fulfilled next
  time_fulfillment_due: DateTime
}

enum UserPowerUpTypeEnumType {
  private
  ghostwriter
  neonDatabasePreview
  egress
  storage
}

union UserPowerUpsTypesOutput =
    UserError
  | UnauthorizedError
  | UserPowerUpsTypes

# State of user-scoped Power Ups
type UserPowerUpsTypes {
  ghostwriter: GhostwriterPowerUpType!
  privateRepls: PrivateReplsPowerUpType!
  neonDatabasePreview: [NeonDatabasePreviewPowerUpType!]!
  egress: [EgressPowerUpType!]!
  storage: StoragePowerUpType!
}

# State of the Ghostwriter Power Up
type GhostwriterPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType
}

# Power Ups which relate to the user (as-compared-with repl-specific Power Ups)
interface UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType
}

# A call-to-action to present to the current user
enum PowerUpCallToActionEnumType {
  # The user should be prompted to activate the feature
  ACTIVATE

  # The user has activated the feature, and an optional call-to-action can be presented to them in light of that
  ACTIVATED

  # The user has activated the feature in the context of a trial
  TRIAL_ONGOING

  # The user had activated the feature in the context of a trial, and the trial has expired
  TRIAL_EXPIRED
}

# The cost associated with a given Power Up
type UserPowerUpCostDetailType {
  cycles: Int!
  explanation: PowerUpCostExplanationEnumType!
}

# State of the Private Repls Power Up
type PrivateReplsPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType
}

# State of the Neon Database Preview Power Up
type NeonDatabasePreviewPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The cost that the user would incur upon purchasing the Power Up
  cost: UserPowerUpCostDetailType
  neonDatabaseName: String!
  connectedRepls: [Repl!]!
}

# State of the Egress Power Up
type EgressPowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # The SKU associated with the Power Up
  sku: EgressAddOnSku

  # The time at which the user purchased the Power Up
  timePurchased: DateTime
}

enum EgressAddOnSku {
  egress_goval_10_gib
  egress_goval_50_gib
  egress_goval_100_gib
  egress_goval_500_gib
  egress_goval_1000_gib
}

# State of the Storage Power Up and associated costs.
type StoragePowerUpType implements UserPowerUpDescriptionByType {
  # Whether the Power Up is active (irrespective of whether it is being paid for or a trial). Note that this is distinct from the "active" field on a cycles_users_orders entry, which itself denote whether the order is set to renew.
  active: Boolean!

  # If active, whether the user's access is due to a trial (rather than a paid subscription)
  isTrial: Boolean!

  # Whether the Power Up will renew (and typically result in a charge for the user)
  willRenew: Boolean!

  # If the user has (or has had) a trial, the expiry date thereof
  timeTrialExpiry: DateTime
  timeLastFulfilled: Date
  timeFulfillmentDue: Date

  # How the user is paying for this Power Up, if they are paying for it (null if they are not)
  methodOfPayment: PowerUpMethodOfPayment

  # What call-to-action to present to the user, if any. Note that some of this information can be derived through other fields on this type, but only partially so (e.g. you wouldn't be able to tell whether the user has already had a trial or not without using this field).
  CTA: PowerUpCallToActionEnumType

  # The Cycles cost that the user would incur upon purchasing the Power Up with Cycles
  cost: UserPowerUpCostDetailType

  # The SKU associated with the current Storage Power Up, if any.
  currentSku: StorageAddOnSku

  # The costs associated with each Storage Power Up
  allSkuCosts: [StorageCostDetailType!]!

  # Time at which the grace period for the storage add-on ends, if any.
  timeGracePeriodEnds: DateTime

  # Whether the storage add-on is in its grace period after a failed renewal.
  isInGracePeriod: Boolean!

  # Days left in the grace period for the storage add-on, if any.
  daysLeftInGracePeriod: Int
}

enum StorageAddOnSku {
  storage_10_gib
  storage_50_gib
  storage_100_gib
  storage_500_gib
  storage_1000_gib
}

# Costs of a Storage Power Ups
type StorageCostDetailType {
  cyclesCostNow: Int!
  cyclesCostRecurring: Int!
  explanation: PowerUpCostExplanationEnumType!
  sku: StorageAddOnSku!
}

union UserPowerUpCost = UnauthorizedError | UserError | UserPowerUpCostsType

# The cost associated with various Power Ups for the user
type UserPowerUpCostsType {
  # Cost for making repls owned by the user private
  private: UserPowerUpCostDetailType!

  # Cost for using Ghostwriter
  ghostwriter: UserPowerUpCostDetailType!
}

union CurrentUserPricesUpdateOptionOutput =
    UserError
  | UnauthorizedError
  | CurrentUserPricesUpdateOptionOutputObject

type CurrentUserPricesUpdateOptionOutputObject {
  option: CurrentUserPricesUpdateOption
}

enum CurrentUserPricesUpdateOption {
  legacy_hacker
  legacy_cycles
  general
}

union UserCourseOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserCourse

union UserCourseLessonOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserCourseLesson

union CurrentUserReplPowerUpsByMethodOfPaymentOutput =
    UnauthorizedError
  | CurrentUserReplPowerUpsByMethodOfPaymentSuccess

type CurrentUserReplPowerUpsByMethodOfPaymentSuccess {
  powerUps: [RenderedPowerUpType!]!
}

type RenderedPowerUpType {
  powerUpType: ReplPowerUpTypeEnumType!
  methodOfPayment: PowerUpMethodOfPayment!
  repl: Repl!
  sku: ReplPowerUpSkuEnumType!
}

union CurrentUserUsageBasedBillingOutput =
    UnauthorizedError
  | UserError
  | ServiceUnavailable
  | UserUsageBasedBillingSummary

# A user's usage-based billing usage and costs summary.
type UserUsageBasedBillingSummary {
  # A user's usage-based billing capabilities.
  capabilities: UserUsageBasedBillingCapabilities!
}

# A user's usage-based billing capabilities.
type UserUsageBasedBillingCapabilities {
  # Whether the user can use usage-based billing services.
  canUseUsageBasedBilling: Boolean!

  # Whether the user has an Orb customer account.
  hasOrbCustomer: Boolean!

  # The reason why the user can or cannot use usage-based billing services.
  explanation: UserUsageBasedBillingCapabilitiesExplanation!

  # Whether the user has a payment method on file that can be used for usage-based billing.
  hasPaymentMethod: Boolean!
}

# The reason why the user can or cannot use usage-based billing services.
enum UserUsageBasedBillingCapabilitiesExplanation {
  # The user does not have a payment method on file.
  NEEDS_PAYMENT_METHOD

  # The user does not have a plan.
  NEEDS_SUBSCRIPTION

  # The user has neither a plan nor payment method.
  NEEDS_SUBSCRIPTION_OR_PAYMENT_METHOD

  # The user needs to verify their phone number to use usage-based billing.
  NEEDS_SMS_VERIFICATION

  # The user is banned from using usage-based billing and needs to be unbanned.
  NEEDS_UNBANNING

  # The user has a plan that includes usage-based billing.
  INCLUDED_IN_SUBSCRIPTION

  # The user has a payment method on file.
  HAS_PAYMENT_METHOD

  # The user has exhausted their budget for the current billing period.
  INSUFFICIENT_BUDGET
}

union CurrentUserUsageOutput =
    UnauthorizedError
  | UserError
  | ServiceUnavailable
  | UsageInterval

# Currently only supports the `current` interval / it defaults to only that for now.
input CurrentUserUsageInput {
  # The interval to show usage information for.
  interval: CurrentUserUsageInterval
}

enum CurrentUserUsageInterval {
  current
}

# Information related to a user's storage utilization.
type StorageInfo {
  # A user's storage utilization summary.
  accountStorageUtilization: AccountStorageUtilizationOutput!

  # A user's storage quota.
  storageQuota: StorageQuotaOutput!

  # A user's storage quota status.
  storageQuotaStatus2: StorageQuotaStatusOutput!

  # A user's grace period storage quota.
  storageGracePeriodQuota: StorageGracePeriodQuotaOutput!
}

union AccountStorageUtilizationOutput =
    UnauthorizedError
  | ServiceUnavailable
  | AccountStorageUtilization

# A user's storage utilization summary.
type AccountStorageUtilization {
  # Storage utilization broken out by Repl.
  perRepl: [ReplStorageUtilization!]!

  # Total bytes of storage used by the account. Represented as a string because GiB can easily exceed int32.
  total: String!
}

# Summary of a Repl's storage utilization.
type ReplStorageUtilization {
  # The Repl for which we are reporting storage utilization.
  repl: Repl!

  # The number of bytes used by the Repl for this month. Represented as a string because GiB can easily exceed int32.
  usage: String!

  # Percentage of usage consumed by this Repl.
  percentage: Float!
}

union StorageQuotaOutput = ServiceUnavailable | StorageQuota

# A user's storage quota.
type StorageQuota {
  # Total bytes in the user's quota. Represented as a string to get around GraphQL's max int size. Returns "0" if not set.
  quota: String!
}

union StorageQuotaStatusOutput = ServiceUnavailable | StorageQuotaStatus

# A user's storage quota status
type StorageQuotaStatus {
  # Whether a user is under, approaching, or exceeding their storage quota
  status: StorageQuotaEnum!
}

enum StorageQuotaEnum {
  ExceedingQuota
  ApproachingQuota
  UnderQuota
}

union StorageGracePeriodQuotaOutput =
    ServiceUnavailable
  | StorageGracePeriodQuota

# A user's storage quota.
type StorageGracePeriodQuota {
  # Total bytes in the user's grace period quota (if present). Represented as a string to get around GraphQL's max int size. Returns "0" if not set.
  quota: String!
}

union UserPaymentMethod = UnauthorizedError | PaymentMethod

union UserCyclesAutoRefillConfigurationOutput =
    UnauthorizedError
  | CyclesAutoRefillConfiguration

# Cycles Auto-Refill configuration for a user
type CyclesAutoRefillConfiguration {
  id: Int!
  enabled: Boolean!
  refillAmount: Int!
  monthlyBudget: Int
}

enum RecentReplsFilter {
  own
  multiplayer
}

type Keybindings {
  keybindings: JSON
}

enum KeybindingsEnvironmentEnum {
  mobile_app
  mobile_web
  desktop_app
  desktop_web
}

enum KeybindingsPlatformEnum {
  linux
  mac
  windows
}

input CurentUserHostingDeploymentsInput {
  count: Int
  after: String
  deploymentType: HostingMachineConfigurationProvider
}

union CurrentUserUsageBasedBillingBudgetOutput =
    UnauthorizedError
  | UsageBasedBillingBudget

# Usage-based billing budget for a user
type UsageBasedBillingBudget {
  id: Int!
  monthlyBudgetUsd: Int!

  # Whether the user has reached their budget for the current billing period
  hasReachedBudget: Boolean!
}

# A workspace layout belonging to a user
type UserWorkspaceLayout {
  id: String!
  name: String!
  state: SequelizeJSON!
}

union PublicSshKeysResult = UnauthorizedError | PublicSshKeysOutput

# List of public ssh keys
type PublicSshKeysOutput {
  keys: [PublicSshKey!]!
}

# Public SSH key
type PublicSshKey {
  id: String!
  key: String!

  # Time the key was created
  timeCreated: DateTime!
  label: String!
}

union CurrentUserOrgOutput = NotFoundError | Org

union CurrentUserOrgsOutput =
    NotFoundError
  | UserError
  | CurrentUserOrganizationConnection

# A connection to a list of CurrentUserOrganizations.
type CurrentUserOrganizationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of CurrentUserOrganizations.
  items: [CurrentUserOrganization!]!
}

# An organization a user is a member of, and their associated system group
type CurrentUserOrganization {
  org: Org!
  type: SystemOrgGroupType!
}

union ReplQueryOutput = Repl | ReplRedirect | SubscriptionExpiredError

# Redirect information for a Repl that has been renamed or owned by user
type ReplRedirect {
  replUrl: String!
  repl: Repl
}

# A user can no longer access their Repl because it is private and they are no longer subscribed
type SubscriptionExpiredError {
  replId: String!
  title: String
  isOwner: Boolean!
}

union TeamOrganizationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TeamOrganization

# If a user has seen a given tour.
type ToursSeenQueryResult {
  seen: Boolean!
}

union TeamOutput = Team | UserError

union BoardReports = UnauthorizedError | BoardReportConnection

# A connection to a list of BoardReports.
type BoardReportConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BoardReports.
  items: [BoardReport!]!
}

# A report on a post or comment
type BoardReport {
  id: Int!
  reportedUserId: Int
  reason: String
  resolved: Boolean!
  timeCreated: Date!
  isEscalated: Boolean
  creator: User
  reportedUser: User
  type: String!
  post: Post
  comment: Comment
  replComment: ReplComment
  bounty: Bounty
  bountyApplication: BountyApplication
  customTheme: CustomTheme
  repl: Repl
}

# A comment on a post or another comment
type Comment {
  id: Int!
  body: String!
  voteCount: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  user: User
  url: String!
  post: Post
  repl: Repl
  parentComment: Comment
  comments: [Comment]
  isAuthor: Boolean!
  canEdit: Boolean!
  canVote: Boolean!
  canComment: Boolean!
  hasVoted: Boolean!
  canReport: Boolean!
  hasReported: Boolean!
  isAnswer: Boolean!
  canSelectAsAnswer: Boolean!
  canUnselectAsAnswer: Boolean!
  preview(length: Int, removeMarkdown: Boolean): String!
}

# A comment on a post or another comment
type ReplComment {
  id: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  body(removeMarkdown: Boolean): String!
  user: User
  isHidden: Boolean
  repl: Repl
  parentComment: ReplComment
  post: Post
  replies: [ReplComment!]!
  canEdit: Boolean! @deprecated(reason: "Use currentUserPermissions.edit")
  canComment: Boolean!
  currentUserPermissions: ReplCommentPermissions
}

# Allowed actions to be taken by the user viewing a comment
type ReplCommentPermissions {
  id: Int!
  edit: Boolean!
  delete: Boolean!
  banAuthor: Boolean!
  canHideComment: Boolean!
  report: Boolean!
}

# Input type for board reports query
input BoardReportsInputType {
  after: Int
  limit: Int
  resolved: Boolean
  escalated: Boolean
  target: BoardReportsTargetType
  order: BoardReportsOrderType
  reporter: Int
}

enum BoardReportsTargetType {
  post
  comment
  repl
  replComment
  reportedUser
  bounty
  bountyApplication
  customTheme
}

enum BoardReportsOrderType {
  newest
  oldest
}

# A connection to a list of Notifications.
type NotificationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Notifications.
  items: [Notification!]!
}

union Notification =
    MentionedInPostNotification
  | MentionedInCommentNotification
  | RepliedToCommentNotification
  | RepliedToPostNotification
  | AnswerAcceptedNotification
  | MultiplayerJoinedEmailNotification
  | MultiplayerJoinedLinkNotification
  | MultiplayerInvitedNotification
  | MultiplayerOverlimitNotification
  | WarningNotification
  | TeamInviteNotification
  | TeamOrganizationInviteNotification
  | BasicNotification
  | TeamTemplateSubmittedNotification
  | TeamTemplateReviewedStatusNotification
  | AnnotationNotification
  | ReplCommentCreatedNotification
  | ReplCommentReplyCreatedNotification
  | ReplCommentMentionNotification
  | ThreadNotification
  | NewFollowerNotification
  | BountyApplicationReviewedNotification
  | BountyNewApplicationNotification
  | BountyNewSubmissionNotification
  | BountySubmissionReviewedNotification
  | BountyChatMessageNotification
  | EgressLimitNotification

# Notification for when a user is at-metioned in a post
type MentionedInPostNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  post: Post
}

# Notification for when a user is at-metioned in a comment
type MentionedInCommentNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's comment has been replied to
type RepliedToCommentNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's post is commented on
type RepliedToPostNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  comment: Comment
}

# Notification for when a user's comment was marked as the answer
type AnswerAcceptedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  post: Post
}

# Notification for when a user joined a multiplayer session via email invite
type MultiplayerJoinedEmailNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user joined a multiplayer session via email link
type MultiplayerJoinedLinkNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user gets an invite to collab on a multiplayer repl
type MultiplayerInvitedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user tried to join a multiplayer session but couldnt due to limits
type MultiplayerOverlimitNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user is warned.
type WarningNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user is invited to a team.
type TeamInviteNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  invite: TeamInvite
}

# Notification for when a user is invited to an organization.
type TeamOrganizationInviteNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  invite: TeamOrganizationInvite
}

# The default Replit Notification type
type BasicNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user submits a project repl
type TeamTemplateSubmittedNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
}

# Notification for when a user's Repl submission has been marked as reviewed, or marked as no longer reviewed
type TeamTemplateReviewedStatusNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  repl: Repl
}

# Notification for when a user receives an annotation
type AnnotationNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A comment was made on a repl
type ReplCommentCreatedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A comment was replied to
type ReplCommentReplyCreatedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user was mentioned in a Repl comment or reply
type ReplCommentMentionNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  replComment: ReplComment
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Notification for when a user receives an update on their thread
type ThreadNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  participants: [User!]!
  thread: AnnotationAnchor
}

# notification for when you gain a new follower
type NewFollowerNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# The poster has reviewed an application
type BountyApplicationReviewedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  isAccepted: Boolean
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user applied to a bounty
type BountyNewApplicationNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A new submission was made for a bounty
type BountyNewSubmissionNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# Bounty poster has reviewed a submission
type BountySubmissionReviewedNotification {
  id: Int!
  url: String!
  seen: Boolean!
  creator: User
  bounty: Bounty
  isAccepted: Boolean
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

# A user has sent a message or messages in a bounty chat
type BountyChatMessageNotification {
  id: Int!
  url: String!
  text: String
  seen: Boolean!
  context: String!
  creator: User
  timeCreated: DateTime!
  timeUpdated: DateTime!
  bounty: Bounty
  unreadCount: Int
  message: BountyChatMessage
}

# Represents a message in a Bounty chat
type BountyChatMessage {
  id: Int!
  message: String!
  timeCreated: DateTime!
  timeUpdated: DateTime!

  # The BountyApplication that this message is for
  bountyApplication: BountyApplication

  # The User that sent this message
  user: User
}

# A user is notified when they are approaching or have reached their monthly egress limit.
type EgressLimitNotification {
  id: Int!
  url: String!
  seen: Boolean!
  variant: notificationsvariantEnumType
  timeCreated: DateTime!
  timeUpdated: DateTime!
  limitGib: Float!
  percentage: Float!
}

enum notificationsvariantEnumType {
  mentioned_in_post
  mentioned_in_comment
  replied_to_post
  replied_to_comment
  answer_accepted
  multiplayer_joined_email
  multiplayer_joined_link
  multiplayer_invited
  multiplayer_overlimit
  warning
  new_achievement_unlocked
  team_subscription
  team_member_limit
  team_template_published
  team_template_reviewed_status
  team_invite
  team_organization_invite
  team_member_joined
  team_template_submitted
  new_annotation_mention
  new_annotation_message
  edit_request_created
  edit_request_accepted
  repl_comment_created
  repl_comment_reply_created
  repl_comment_mention
  thread_update
  new_follower
  bounty_new_application
  bounty_application_reviewed
  bounty_new_submission
  bounty_submission_reviewed
  bounty_chat_message
  tip_received
  egress_approaching_limit
  egress_reached_limit
  payment_failed
  suspended_from_usage_based_billing
  flexible_credits_usage_alert
  usage_limit_exhausted
  usage_limit_warning
}

# An object for fields restricted to admins
type Admin {
  user: User!
}

type CluiQuery {
  # Admin CLUI operations
  admin: AdminCluiQuery

  # Staff CLUI operations
  staff: StaffCluiQuery

  # Manage your account
  account: UserCliAccountQuery

  # Moderator CLUI operations
  moderator: ModeratorCluiQuery

  # List and restore deleted repls and folders
  trash: TrashQuery

  # View and manage your teams
  team: TeamQuery

  # View and manage extensions you've made
  extension: ExtensionQuery
}

type AdminCluiQuery {
  # View, impersonate, ban, etc.
  user: AdminCliUserQuery

  # Manage site settings
  site: AdminCliSiteQuery

  # Manage user roles
  roles: AdminCliRolesQuery

  # View a team organization
  team: AdminTeamOrgQuery

  # Manage site banner
  banners: AdminCliBannersQuery

  # Set app wide key/value
  appEnv: AdminCliAppEnvQuery

  # Configure templates
  templates: AdminCliTemplatesQuery

  # View and publish curriculum hub content
  curriculum: AdminCurriculumHubQuery

  # Configure organizations
  org: AdminCliBillingOrgsQuery

  # Support tools
  support: AdminCliSupportQuery

  # Configure subscriptions
  subscriptions: AdminCliSubscriptionsQuery

  # View and update manually curated content for trending
  curation: ManualCurationQuery

  # View and manage extensions on Replit
  extension: AdminCliExtensionQuery

  # View, Delete, etc.
  cloudServices: AdminCliCloudServicesQuery
}

type AdminCliUserQuery {
  # View user info
  view(
    # User's username or email
    user: String!
  ): CluiOutput

  # View and manage users' Cycles balances
  cycles: AdminCliUserCyclesQuery

  # Manage usage-based billing for users.
  usageBasedBilling: AdminCliUserUsageBasedBillingQuery
}

union CluiOutput =
    CluiSuccessOutput
  | CluiMarkdownOutput
  | CluiTableOutput
  | CluiComponentOutput
  | CluiErrorOutput

type CluiSuccessOutput {
  message: String!
  json: JSON
}

type CluiMarkdownOutput {
  markdown: String!
}

type CluiTableOutput {
  columns: [CluiTableColumn!]!
  rows: [JSON!]!
}

type CluiTableColumn {
  label: String!
  key: String!
}

type CluiComponentOutput {
  component: String!
}

type CluiErrorOutput {
  error: String!
  json: JSON
}

type AdminCliUserCyclesQuery {
  # Get a user's Cycles balance.
  balance(
    # The username or email of the user
    username: String!
  ): CluiOutput
}

type AdminCliUserUsageBasedBillingQuery {
  # Check if user is eligible for usage-based billing. This is useful for testing and debugging.
  isEligible(
    # The username or email of a single user
    target: String!
  ): CluiOutput
}

type AdminCliSiteQuery {
  # Gets the commit version of this build
  version: CluiOutput
}

type AdminCliRolesQuery {
  # View roles for a user
  view(
    # User's username or email
    user: String!
  ): CluiOutput
}

type AdminTeamOrgQuery {
  # View team members
  viewTeamMembers(
    # team name
    team: String!
  ): CluiOutput
}

type AdminCliBannersQuery {
  # View latest unresolved banner
  view: CluiOutput
}

type AdminCliAppEnvQuery {
  # List app environment variables
  list: CluiOutput
}

type AdminCliTemplatesQuery {
  # View and update associations between languages and template repls
  languages: CluiOutput

  # View and manage template categories
  categories: AdminCliTemplatesCategoriesQuery

  # Approve Template Repl submissions.
  submissions: CluiOutput
}

type AdminCliTemplatesCategoriesQuery {
  # Add or edit a template category.
  view: CluiOutput

  # Assign template categories to Template Repls.
  assign: CluiOutput
}

type AdminCurriculumHubQuery {
  # View curriculum
  viewCurriculum(
    # Curriculum url slug
    slug: String
  ): CluiOutput
}

type AdminCliBillingOrgsQuery {
  # Show all organizations a user is a member of and all members of those organizations.
  view(
    # Team or user name
    teamOrUserName: String!
  ): CluiOutput
}

type AdminCliSupportQuery {
  # send emails to all unverified users
  verifyEduUsers: CluiOutput

  # View user and Repl data for debugging (and tickets)
  info(
    # a username, userid, email, replid, or the link to a Repl (prefix with `https://`, can be repl.co or repl.com)
    userOrRepl: String!

    # if true, userOrRepl is a user id
    isUserId: Boolean
  ): CluiOutput

  # View user and Repl data (used by anti-abuse)
  info2(
    # Takes a username, user id, email, repl id, or repl url and spits out whatever it can find!
    input: String!
  ): CluiOutput
}

type AdminCliSubscriptionsQuery {
  # View subscriptions by username or organization ID
  view(
    # username or email
    username: String

    # organization ID
    orgId: Int
  ): CluiOutput
}

type ManualCurationQuery {
  # View Trending Repl picks
  list: CluiOutput
}

type AdminCliExtensionQuery {
  # View extensions people have created. Returns all extensions by default
  view(
    # The creator's @username or id. (prefix with @ to search by username)
    creator: String
  ): CluiOutput
}

type AdminCliCloudServicesQuery {
  # View, Delete.
  neonDatabase: AdminCliNeonDatabaseQuery
}

type AdminCliNeonDatabaseQuery {
  # View Neon database properties.
  view(
    # The ID of the repl associated with the Neon database
    replId: String!
  ): CluiOutput
}

type StaffCluiQuery {
  # Manage bounties and bounty-related data
  bounties: StaffBountiesQuery
}

type StaffBountiesQuery {
  # Review a list of Bounty Applications that need to be moderated
  applicationReviewQueue: CluiOutput
}

type UserCliAccountQuery {
  # View warnings you have been issued.
  viewWarns: CluiOutput

  # You can use the balance to convert Cycles to usage credits. To do that, navigate to your profile and select CLUI. Search for **cycles-to-usage-credits** and enter the number of Cycles. Note that a minimum of 1 Cycle (equivalent to $0.01 usage credit) is required for the conversion.
  usageCreditsBalance: CluiOutput
}

type ModeratorCluiQuery {
  # View Repl Talk bans
  viewBans: CluiOutput

  # Manage a post.
  post: ModeratorCliPostQuery

  # Ban, warn, view-warns, etc.
  user: ModeratorCliUserQuery

  # View moderator audits
  audit: ModeratorCliAuditQuery
}

type ModeratorCliPostQuery {
  # View a post/comments voters.
  showVotes(
    # The post's id
    postId: Int

    # The comment's id
    commentId: Int
  ): CluiOutput
}

type ModeratorCliUserQuery {
  # View a users warnings.
  viewWarns(
    # User's username or email
    user: String!
  ): CluiOutput
}

type ModeratorCliAuditQuery {
  # View the moderator audit log.
  viewAudit(
    # The creator of the action
    creator: String

    # The model the audit is for
    model: ModeratorAuditModels

    # The type of the action
    actionType: ModeratorAuditActionType

    # The page of audits
    page: Int

    # What order to show the results in
    order: ModeratorAuditSorting
  ): CluiOutput

  # View the moderator audit log.
  viewItem(id: Int!): CluiOutput
}

# The accessible models for the moderator audit.
enum ModeratorAuditModels {
  BannedBoardUsers
  Warning
  Comments
  Posts
  BoardReports
}

enum ModeratorAuditActionType {
  CREATE
  DELETE
  UPDATE
}

enum ModeratorAuditSorting {
  # Sort newest to oldest
  NEWEST

  # Sort oldest to newest
  OLDEST
}

type TrashQuery {
  # View Repls deleted in the last month.
  viewRepls: CluiOutput

  # View folders deleted in the last month
  viewFolders: CluiOutput
}

type TeamQuery {
  # View the members of your team
  view(
    # team name
    team: String!
  ): CluiOutput
}

type ExtensionQuery {
  # View extensions you have created
  view: CluiOutput
}

union CustomThemeByIdOutput = NotFoundError | CustomTheme

input CustomThemeByIdInput {
  themeId: Int!
}

union ThemesSearchOutput = UserError | UnauthorizedError | CustomThemeConnection

input ThemesSearchInput {
  after: String
  count: Int
  searchQuery: String
  authorId: Int
  colorScheme: CustomThemeColorScheme
  colorValue: String
}

union AnnotationQueryOutput = AnnotationAnchor | UserError

# A Repl and the connections to it
type ReplConnections {
  # The Repl which users are connected to
  repl: Repl!

  # The users that are connected to the Repl
  users: [User!]!

  # The time when the data was returned
  epoch: DateTime!
}

# A site banner
type Banner {
  id: Int!
  message: String!
}

union GetGoogleClassroomCoursesOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | GoogleClassroomCourseOutput

type GoogleClassroomCourseOutput {
  courses: [GoogleClassroomCourseInfo]!
}

type GoogleClassroomCourseInfo {
  id: String!
  name: String!
}

union GetGoogleClassroomStudentsOutput =
    UserError
  | UnauthorizedError
  | GoogleClassroomStudentOutput

type GoogleClassroomStudentOutput {
  students: [GoogleClassroomStudentInfo]!
}

type GoogleClassroomStudentInfo {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
}

union ReplTemplateOutput = UnauthorizedError | NotFoundError | ReplTemplate

union CurriculumBySlugOutput = UnauthorizedError | NotFoundError | Curriculum

union TemplateRepls2Output = UserError | TemplateReplSearchConnection

type TemplateReplSearchConnection {
  items: [Repl!]!
  searchQuery: String!
  total: Int!
  orderBy: TemplateRepls2OrderBy!
  promotionStatus: TemplateRepls2PromotionStatus!
  pageInfo: PageInfo!
  category: Int
}

enum TemplateRepls2OrderBy {
  forks
  recent
  searchRelevancy
}

enum TemplateRepls2PromotionStatus {
  all
  promoted
  notPromoted
}

input TemplateRepls2QueryOptions {
  after: Int
  searchQuery: String
  count: Int
  promotionStatus: TemplateRepls2PromotionStatus
  orderBy: TemplateRepls2OrderBy
  category: Int
}

input ReplPostsQueryOptions {
  after: String
  searchQuery: String
  count: Int
  order: ReplPostsOrder
  boardSlugs: [String!]
  tags: [String!]
}

enum ReplPostsOrder {
  Hot @deprecated(reason: "Use Top instead")
  New
  Top
}

type TagGroups {
  official(limit: Int, search: String): [Tag!]!
  community(limit: Int, search: String): [Tag!]!
}

union PreviewInvoice =
    UserError
  | NotFoundError
  | UnauthorizedError
  | PreviewInvoiceOutput

type PreviewInvoiceOutput {
  total: Float!
  balance: Float!
  chargeDate: DateTime
  currentItems: [PreviewInvoiceLineItemGroup!]!
  upcomingItems: [PreviewInvoiceLineItemGroup!]!
}

type PreviewInvoiceLineItemGroup {
  periodStart: DateTime!
  periodEnd: DateTime!
  type: String!
  items: [PreviewInvoiceLineItem!]!
}

type PreviewInvoiceLineItem {
  description: String
  amount: Float!
  quantity: Int
}

input PreviewInvoiceInput {
  orgId: Int!
  product: PreviewInvoiceLineItemInput!
}

input PreviewInvoiceLineItemInput {
  # Product ID (only if changing subscribed product)
  id: Int

  # Subscription quantity (only if changing quantity)
  quantity: Int
}

union SearchQueryOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | SearchQueryResults

type SearchQueryResults {
  replResults: SearchQueryResultsRepls!
  templateResults: SearchQueryResultsTemplates!
  fileResults: SearchQueryResultsFiles!
  userResults: SearchQueryResultsUsers!
  postResults: SearchQueryResultsPosts!
  docResults: SearchQueryResultsDocs!
  tagResults: SearchQueryResultsTags!
}

type SearchQueryResultsRepls {
  hitInfo: SearchQueryHitInfo!
  results: ReplConnection!
}

# Information about how many hits there were for a search
type SearchQueryHitInfo {
  totalHits: Int!
  totalPages: Int!
}

type SearchQueryResultsTemplates {
  hitInfo: SearchQueryHitInfo!
  results: ReplConnection!
}

type SearchQueryResultsFiles {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultIndexedFileConnection!
}

# A connection to a list of SearchResultIndexedFiles.
type SearchResultIndexedFileConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultIndexedFiles.
  items: [SearchResultIndexedFile!]!
}

# An indexed file returned from file search
type SearchResultIndexedFile {
  repl: Repl!
  filePath: String!
  fileContents: String!
  fileContentMatches: [SearchResultIndexedFileMatches!]!
}

# The location of a match in a SearchResultIndexedFile's fileContents
type SearchResultIndexedFileMatches {
  start: Int!
  length: Int!
}

type SearchQueryResultsUsers {
  hitInfo: SearchQueryHitInfo!
  results: UserConnection!
}

type SearchQueryResultsPosts {
  hitInfo: SearchQueryHitInfo!
  results: PostConnection!
}

type SearchQueryResultsDocs {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultIndexedDocConnection!
}

# A connection to a list of SearchResultIndexedDocs.
type SearchResultIndexedDocConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultIndexedDocs.
  items: [SearchResultIndexedDoc!]!
}

# An indexed doc returned from doc search
type SearchResultIndexedDoc {
  path: String!
  section: String!
  contents: String!
  contentMatches: [SearchResultIndexedFileMatches!]!
}

type SearchQueryResultsTags {
  hitInfo: SearchQueryHitInfo!
  results: SearchResultTagConnection!
}

# A connection to a list of SearchResultTags.
type SearchResultTagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of SearchResultTags.
  items: [SearchResultTag!]!
}

# An indexed tag returned from tag search
type SearchResultTag {
  tag: Tag!
  timeLastUsed: DateTime!
  numReplsTotal: Int!
}

input SearchQueryOptions {
  query: String!
  categories: [SearchQueryCategory!]!
  onlyCalculateHits: Boolean
  categorySettings: SearchCategorySettings
}

enum SearchQueryCategory {
  Repls
  Templates
  Files
  Users
  Posts
  Docs
  Tags
}

input SearchCategorySettings {
  repls: SearchQueryReplsSearchSettings
  templates: SearchQueryTemplatesSearchSettings
  files: SearchQueryFilesSearchSettings
  posts: SearchQueryPostsSearchSettings
  users: SearchQueryUsersSearchSettings
  docs: SearchQueryDocsSearchSettings
  tags: SearchQueryTagsSearchSettings
}

input SearchQueryReplsSearchSettings {
  sort: SearchQueryReplSort
  page: SearchQueryPageFilter
  dateCreated: SearchQueryDateFilter
  dateModified: SearchQueryDateFilter
  ownerId: Int
  tags: [String!]
  exactMatch: Boolean
}

enum SearchQueryReplSort {
  Relevant
  Trending
  RecentlyCreated
  RecentlyModified
  MostLikes
  MostRuns
  MostForks
}

# Filter to set the page number (via after) and how many results should be fetched (via first)
input SearchQueryPageFilter {
  after: String
  first: Int
}

input SearchQueryDateFilter {
  gte: DateTime!
}

input SearchQueryTemplatesSearchSettings {
  page: SearchQueryPageFilter
  status: SearchQueryTemplateStatus
  ownerId: Int
  exactMatch: Boolean
}

enum SearchQueryTemplateStatus {
  All
  Official
  Community
}

input SearchQueryFilesSearchSettings {
  sort: SearchQueryFileSort
  page: SearchQueryPageFilter
  fileExtension: String
  exactMatch: Boolean
  myCode: Boolean
}

enum SearchQueryFileSort {
  Relevant
  RecentlyModified
}

input SearchQueryPostsSearchSettings {
  sort: SearchQueryPostSort
  page: SearchQueryPageFilter
  dateCreated: SearchQueryDateFilter
  exactMatch: Boolean
}

enum SearchQueryPostSort {
  Relevant
  RecentlyCreated
  Trending
  MostVotes
  MostComments
}

input SearchQueryUsersSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
}

input SearchQueryDocsSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
  section: String
}

input SearchQueryTagsSearchSettings {
  page: SearchQueryPageFilter
  exactMatch: Boolean
}

union ThreadsByFileOutput =
    NotFoundError
  | UnauthorizedError
  | ThreadsByFileResult

type ThreadsByFileResult {
  threads: [AnnotationAnchor!]!
}

# A connection to a list of UserEvents.
type UserEventConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of UserEvents.
  items: [UserEvent!]!
}

# User events triggered by current user's followed users.
type UserEvent {
  id: Int!
  eventType: user_eventseventTypeEnumType!
  timeUpdated: Date!
  user: User!
  following: User
  comment: ReplComment
  post: Post
  reaction: ReplReaction
  repl: Repl
}

enum user_eventseventTypeEnumType {
  user_comment
  publish_post
  update_post
  publish_template
  update_template
  create_reaction
  user_following
}

# User events triggered by current user's following users.
type ReplReaction {
  id: Int!
  userId: Int!
  reactionType: repl_reactionsreactionTypeEnumType!
  repl: Repl
}

enum repl_reactionsreactionTypeEnumType {
  heart
  rocket
  eyes
  fire
  open_mouth
}

union TutorialReplsOutput = UnauthorizedError | TutorialReplsResults

type TutorialReplsResults {
  results: [Repl!]!
}

input TutorialReplsInput {
  category: TutorialReplsCategory!
}

enum TutorialReplsCategory {
  all
  codealong
  highlighted
  remix
}

union InstantGitHubImportOutput =
    NotFoundError
  | UserError
  | InstantGitHubImportResult

type InstantGitHubImportResult {
  language: String!
  templateId: String!
  isPrivate: Boolean!
}

input InstantGitHubImportInput {
  username: String!
  repository: String!
}

union ModeratorAuditLogOutput = UnauthorizedError | ModeratorAuditLogConnection

# A connection to a list of ModeratorAuditLogs.
type ModeratorAuditLogConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ModeratorAuditLogs.
  items: [ModeratorAuditLog!]!
}

# A moderator audit log entry.
type ModeratorAuditLog {
  id: Int!
  model: moderator_action_recordmodelEnumType!
  type: moderator_action_recordtypeEnumType!
  updateBody: String
  moderator: User
  post: Post
  comment: ReplComment
  bannedUser: User
  boardReport: BoardReport
  warnedUser: User
  repl: Repl
  notification: BasicNotification
  bountyApplication: BountyApplication
  customTheme: CustomTheme
  timeCreated: DateTime!
  timeUpdated: DateTime!
}

enum moderator_action_recordmodelEnumType {
  Boards
  Posts
  Comments
  BannedBoardUsers
  BoardReports
  Warning
  Repls
  Notifications
  BountyApplications
  CustomThemes
}

enum moderator_action_recordtypeEnumType {
  create
  update
  delete
}

# Additional options for pagination and filtering audit log
input ModeratorAuditLogInputType {
  after: Int
  limit: Int
  moderator: Int
  model: ModeratorAuditLogModel
  type: ModeratorAuditLogType
  targetId: Int
  replId: String
  order: ModeratorAuditLogOrder
}

enum ModeratorAuditLogModel {
  boards
  posts
  comments
  bannedBoardUsers
  boardReports
  warning
  repls
  notifications
  bountyApplications
  customThemes
}

enum ModeratorAuditLogType {
  create
  update
  delete
}

enum ModeratorAuditLogOrder {
  newest
  oldest
}

union ImageScansOutput = UserError | UnauthorizedError | ImageScanConnection

# A connection to a list of ImageScans.
type ImageScanConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of ImageScans.
  items: [ImageScan!]!
}

type ImageScan {
  # Image scan classification ID
  id: Int!

  # ID of the image that corresponds to the scan
  image_id: Int!

  # Context in which the image was uploaded
  upload_context: String!

  # URL to the image
  image_url: String!

  # User who uploaded the image
  creator: User!

  # Score associated to the image by the scanning model
  score: Float!

  # When the image was uploaded
  time_image_uploaded: DateTime

  # When the image scan was completed
  time_scan_results_obtained: DateTime

  # Whether the image scan has been resolved
  resolved: Boolean!
}

# Teacher verification information
type TeacherVerification {
  userId: Int!
  formResponses: SequelizeJSON!

  # email of the user that submitted the verification request
  email: String!

  # username of the user that submitted the verification request
  username: String!
}

union CourseLessonsReplsOutput = NotFoundError | CourseLessonsRepls

type CourseLessonsRepls {
  # A list of lesson identifier / repl pairs
  results: [LessonRepl!]!
}

# A lesson / repl pair
type LessonRepl {
  lessonSlug: String!
  repl: Repl!
}

union BountyByIdOutput = NotFoundError | UnauthorizedError | Bounty

input BountyByIdInput {
  id: Int!
}

union BountySearchOutput =
    UserError
  | UnauthorizedError
  | BountySearchConnection

# A connection to a list of Bounties
type BountySearchConnection {
  items: [Bounty!]!
  pageInfo: PageInfo!
}

input BountySearchInput {
  # Controls which page of results to fetch
  after: String

  # How many Bounties to fetch in this page of results
  count: Int

  # The query to use to filter results
  searchQuery: String

  # The ID of a Bounty Hunter to use to filter results
  hunterId: Int

  # The ID of a Bounty Poster to use to filter results
  posterId: Int

  # Use statuses filter instead
  status: BountySearchStatusFilter

  # The statuses to include when searching for Bounties, if none are specified, this will include Bounties with any status
  statuses: [BountySearchStatus!]

  # The order to use when sorting the results
  order: BountySearchOrder

  # Filters applied to the Bounty's reward
  cycles: BountySearchInputCyclesFilter

  # Filters applied to the Bounty's time created
  timeCreated: BountySearchInputTimeCreatedFilter

  # Filters applied based on Bounty's listing state
  listingState: BountySearchListingStateFilter
}

enum BountySearchStatusFilter {
  all
  inProgress
  open
  canceled
  completed
}

enum BountySearchStatus {
  inProgress
  open
  canceled
  completed
}

enum BountySearchOrder {
  # The default recommended sort
  recommended

  # Sort Bounties with the lowest applications to the top
  applicationCountAscending

  # Sort Bounties with the highest reward to the top
  cyclesDescending

  # Sort Bounties created most recently to the top
  creationDateDescending

  # Sort Bounties updated most recently to the top
  lastUpdatedDateDescending
}

input BountySearchInputCyclesFilter {
  # Filters Bounties to those with cycles greater than or equal to this amount
  gte: Int!
}

input BountySearchInputTimeCreatedFilter {
  # Filters Bounties to those created at or after this date time
  lte: DateTime!
}

enum BountySearchListingStateFilter {
  all
  unlisted
  listed
}

union GetRecommendedBountiesForUserOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | GetRecommendedBountiesForUserResult

type GetRecommendedBountiesForUserResult {
  # List of recommended Bounties
  results: [Bounty!]!
}

input GetRecommendedBountiesForUserInput {
  # How many recommended Bounties to attempt to find
  count: Int
}

union BountyApplicationByIdOutput =
    NotFoundError
  | UnauthorizedError
  | BountyApplication

input BountyApplicationByIdInput {
  id: Int!
}

union BountyApplicationSearchOutput = UserError | BountyApplicationConnection

# A connection to a list of BountyApplications.
type BountyApplicationConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyApplications.
  items: [BountyApplication!]!
}

input BountyApplicationSearchInput {
  bountyId: Int
  after: String
  count: Int
  order: BountyApplicationSearchOrder
  status: BountyApplicationSearchStatus
}

enum BountyApplicationSearchOrder {
  recommended
  highestRating
  completedBountiesDescending
  applicationDateDescending
  applicationDateAscending
}

enum BountyApplicationSearchStatus {
  all
  accepted
  notReviewed
  rejected
  rejectedAndNotReviewed
  awaitingModeration
}

union BountyChatSearchOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | NotFoundError
  | BountyChatMessageConnection

# A connection to a list of BountyChatMessages.
type BountyChatMessageConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyChatMessages.
  items: [BountyChatMessage!]!
}

input BountyChatSearchInput {
  bountyApplicationId: Int!

  # provide this param to load newer messages in history.
  after: String

  # provide this param to load older messages in history.
  before: String
  count: Int
}

union BountyHunterServiceSearchOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | BountyHunterServiceConnection

# A connection to a list of BountyHunterServices.
type BountyHunterServiceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of BountyHunterServices.
  items: [BountyHunterService!]!
}

# A service that is offered by a Bounty Hunter
type BountyHunterService {
  id: Int!
  title: String!
  description: String!

  # Cycles that it costs to buy this service
  cycles: Int!
    @deprecated(
      reason: "bounty services now support a range of prices or a single price, so this field is deprecated. Use 'cycles2' instead."
    )

  # Cycles that it costs to buy this service
  cycles2: BountyHunterServiceCyclesRange!

  # Cover image for this service
  imageUrl: String!

  # Time to complete this service in seconds
  timeToComplete: Int!

  # Whether or not this service is available to be purchased currently
  isAvailable: Boolean!

  # Whether or not this service is publicly listed
  isUnlisted: Boolean!

  # User who is providing this service
  user: User
}

# A range of cycles that it costs to buy this service
type BountyHunterServiceCyclesRange {
  min: Int!
  max: Int!
}

input BountyHunterServiceSearchInput {
  # Unused, but setting API up for pagination
  after: String

  # Unused, but setting API up for pagination
  count: Int
}

union BountyHunterServiceByIdOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyHunterService

input BountyHunterServiceByIdInput {
  id: Int!
}

union BountyByUrlOutput = NotFoundError | UnauthorizedError | Bounty

input BountyByUrlInput {
  slug: String!
  username: String!
}

union TemplateCategoriesOutput = UserError | TemplateCategoriesResults

type TemplateCategoriesResults {
  # A list of template categories.
  results: [TemplateCategory!]!
}

input TemplateCategoriesInput {
  # Only return set list of template categories by their ids in order improve test reliability.
  ids: [Int!]!
}

union TemplateCategoryBySlugOutput =
    UserError
  | NotFoundError
  | TemplateCategory

input TemplateCategoryBySlugInput {
  # unique slug associated with a template category
  slug: String!
}

# An object with upload and download URLs for support assets
type SupportAssetUrls {
  uploadUrl: String!
  downloadUrl: String!
  contentType: String!
}

type Extension {
  id: String!
  name: String!
  description: String!
  url: String
  slug: String
  isBlessed: Boolean!
  isListed: Boolean!
  isFeatured: Boolean!
  isDisabled: Boolean!
  timeCreated: Date!
  timeUpdated: Date
  user: User!
  installation(replId: String): ExtensionInstallation
  manifest: ExtensionManifestResult
  installCount: String!
  sourceRepl: Repl
  enableInternalApi: Boolean!

  # Whether the current user can deploy this extension
  canDeployExtension: Boolean!
}

type ExtensionInstallation {
  id: String!
  timeCreated: Date!
  timeUpdated: Date

  # The repl to which the extension is installed
  repl: Repl
  extension: Extension

  # The user to whom the extension is installed
  user: User

  # The user who installed the extension
  installer: User

  # A signed JWT that an extension can use to authenticate a user
  token: String
}

union ExtensionManifestResult = ExtensionManifest | ExtensionManifestError

type ExtensionManifest {
  name: String!
  description: String!
  version: String
    @deprecated(reason: "We deprecated the manifest version field")
  scopes: [ExtensionScope!]
  icon: String
  tags: [String!]
  supportEmail: String
  website: String
  longDescription: String
  coverImages: [ExtensionCoverImage!]
  features: [ExtensionFeature!]
  fileHandlers: [ExtensionFileHandler!]
  tools: [ExtensionTool!]
  background: ExtensionBackground
}

type ExtensionScope {
  name: String!
  reason: String!
}

type ExtensionCoverImage {
  url: String!
  path: String!
  label: String!
}

type ExtensionFeature {
  image: String
  title: String!
  body: String!
}

type ExtensionFileHandler {
  glob: String!
  handler: String!
  name: String
  icon: String
}

type ExtensionTool {
  handler: String!
  name: String
  icon: String
}

type ExtensionBackground {
  page: String!
}

type ExtensionManifestError {
  message: String!
}

union GetBannedBoardUserOutput =
    NotFoundError
  | UnauthorizedError
  | BannedBoardUser

# Users who are banned from social boards
type BannedBoardUser {
  id: Int!
  reason: String!
  timeExpired: Date
  timeCreated: Date!
  isActive: Boolean!
  user: User
  creator: User
}

union StudentsSubmissionsOutput =
    UnauthorizedError
  | UserError
  | StudentsSubmissionsResults

type StudentsSubmissionsResults {
  # A list of student submissions, preserving the order from input.studentIds
  results: [StudentSubmissions!]!
}

type StudentSubmissions {
  userId: Int!
  templateSubmissions: [TemplateSubmission!]!
}

type TemplateSubmission {
  templateId: Int!
  submission: ReplSubmission!
}

# Given sets of student and template IDs, return a list of student submisssions
input StudentsSubmissionsInput {
  teamId: Int!

  # Student User IDs for which we want submissions
  studentIds: [Int!]!

  # Template IDs for which we want submissions
  templateIds: [Int!]!
}

union TipaltiIframeUrl = UserError | UnauthorizedError | TipaltiIframeUrlResult

type TipaltiIframeUrlResult {
  iframeUrl: String!
}

union GetNeonDatabasesOutput =
    UserError
  | UnauthorizedError
  | GetNeonDatabasesResult

type GetNeonDatabasesResult {
  databases: [NeonDatabase!]!
}

type NeonDatabase {
  projectId: String!
  databaseId: Int!
  databaseName: String!
  connectionString: String!
  isFrozen: Boolean!
}

input GetNeonDatabasesInput {
  replId: String!
}

union ReplContinents = UnauthorizedError | ReplContinentsOutput

type ReplContinentsOutput {
  continents: [ReplContinent!]!
}

union AllowedReplIdentityRepls =
    UnauthorizedError
  | AllowedReplIdentityReplsOutput

type AllowedReplIdentityReplsOutput {
  repls: [Repl!]!
}

union ExtensionOutput = NotFoundError | Extension

union ExtensionInstallationByIdOutput = NotFoundError | ExtensionInstallation

union ExtensionInstallationsOutput =
    NotFoundError
  | UnauthorizedError
  | ExtensionInstallationList

type ExtensionInstallationList {
  installations: [ExtensionInstallation!]!
}

union PreviewProrationOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | PreviewProrationResult

# An error of Payment Processor origin
type PaymentError implements Error {
  message: String!
}

type PreviewProrationResult {
  # The total amount of the proration in cents
  prorationTotalInCents: Int!

  # Whether the invoice preview is for a change from a free trial to a paid subscription
  isTrialToPaid: Boolean!
}

input PreviewProrationInput {
  # The plan prefix of the subscription type to change the users current subscription to
  newPlanPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  newPlanPeriod: SelectableSubscriptionPeriodTypesEnum!
}

enum SelectableSubscriptionPrefixTypesEnum {
  hacker
  hacker_pro
}

enum SelectableSubscriptionPeriodTypesEnum {
  monthly
  yearly
}

type SubscriptionPlansOutput {
  free: FreePlan!
  hacker: SubscriptionPlan!
  pro: SubscriptionPlan!
  teams: SubscriptionPlan!
}

type FreePlan {
  displayName: String!
  items: [SubscriptionPlanItem!]!
}

type SubscriptionPlanItem {
  code: SubscriptionPlanItemEnumType!
  description: String!
  details: String
  pillText: String
  learnMoreLink: String
  showOnMobile: Boolean!
}

enum SubscriptionPlanItemEnumType {
  privateRepls
  accountStorage
  dataTransfer
  workspaceSpeed
  alwaysOnRepl
  boostedRepl
  sshCapability
  ghostwriter
}

type SubscriptionPlan {
  displayName: String!
  apple: ProviderPlanDetails!
  google: ProviderPlanDetails!
  stripe: StripeProviderPlanDetails!
  orb: OrbProviderPlanDetails!
  items: [SubscriptionPlanItem!]!
}

type ProviderPlanDetails {
  monthlyPlanDetails: PlanDetails!
  yearlyPlanDetails: PlanDetails!
}

type PlanDetails {
  planId: String!
  googleSubscriptionId: String
  costInUsdCents: Int!
}

type StripeProviderPlanDetails {
  monthlyPlanDetails: StripePlanDetails!
  yearlyPlanDetails: StripePlanDetails!
}

type StripePlanDetails {
  costInUsdCents: Int!
}

type OrbProviderPlanDetails {
  monthlyPlanDetails: OrbPlanDetails!
  yearlyPlanDetails: OrbPlanDetails!
}

type OrbPlanDetails {
  costInUsdCents: Int!
}

union HostingBuildDeployActionHistoryOutput =
    UnauthorizedError
  | NotFoundError
  | HostingBuildDeployActionHistoryResults

# Hosting build deploy action history
type HostingBuildDeployActionHistoryResults {
  build: HostingBuild!
  results: [HostingBuildDeployActionUpdateEvent!]
}

# A hosting deploy action update event
union HostingBuildDeployActionUpdateEvent =
    HostingBuildDeployLogAction
  | HostingBuildDeployStatusAction

type HostingBuildDeployLogAction {
  log: String!
}

type HostingBuildDeployStatusAction {
  build: HostingBuild!
  status: HostingBuildStatus!
  message: String
}

input HostingBuildDeployActionHistoryInput {
  buildId: String!
}

union GetReplitCheckoutSessionOutput =
    NotFoundError
  | UnauthorizedError
  | ReplitCheckoutSession

# A Replit checkout session. Basically a wrapper around a Stripe Payment Intent and provisioning of Replit products.
type ReplitCheckoutSession {
  id: String!
  status: CheckoutSessionStatus!
}

# The status of a Replit Checkout Session
enum CheckoutSessionStatus {
  # The checkout session has been started
  started

  # The checkout session is provisioning cycles
  provisioning_cycles

  # The checkout session is provisioning a product
  provisioning_product

  # Payment for the checkout session has failed (terminal)
  payment_failed

  # The checkout session has succeeded and has been successfully provisioned (terminal)
  succeeded

  # The checkout session has succeeded but provisioning of cycles has failed (terminal)
  cycles_provisioning_failed

  # The checkout session has succeeded but provisioning of the product has failed (terminal)
  product_provisioning_failed
}

input GetReplitCheckoutSessionInput {
  # Checkout session ID
  id: String!
}

union ReplitAppSubdomainAvailabilityOutput =
    UserError
  | ReplitAppSubdomainAvailabilityResult

type ReplitAppSubdomainAvailabilityResult {
  # Whether the subdomain is available for use
  available: Boolean!

  # Additional context about the availability
  message: String
}

union OnboardingTemplatesOutput = UnauthorizedError | OnboardingTemplates

type OnboardingTemplates {
  # A list of curated templates to show during onboarding
  results: [Repl!]!
}

union ExtensionsQueryOutput =
    UserError
  | UnauthorizedError
  | ExtensionConnection

# A connection to a list of Extensions.
type ExtensionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Extensions.
  items: [Extension!]!
}

enum ExtensionInclusionType {
  all
  blessed
  unblessed
}

# The order in which to return extensions
enum ExtensionOrderType {
  old
  new
  top
  random
}

enum ExtensionFilterType {
  all
  installed
}

union GitHubRepoInfoResult =
    ServiceUnavailable
  | UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | GitHubRepoInfoOutput

type GitHubRepoInfoOutput {
  # The repository
  repository: Repository!

  # The recommended template for the repository
  recommendedTemplate: Repl!

  # Top languages used by this repo
  topLanguages: [String!]!

  # Whether the repository is configured for Replit and has a .replit or replit.nix file
  isConfiguredForReplit: Boolean!

  # Whether the repository can be imported
  canBeImported: RepositoryCanBeImported!
}

type RepositoryCanBeImported {
  explanation: RepositoryImportExplanation!
}

enum RepositoryImportExplanation {
  CAN_BE_IMPORTED
  TOO_BIG
  VIOLATES_TOS
}

input GitHubRepoInfoInput {
  # The URL of the GitHub repo to get info for.
  githubRepoUrl: String!
}

union HostingDeploymentOutput = NotFoundError | HostingDeployment

union GetTemplateInfoForFilePathOutput =
    UnauthorizedError
  | TooManyRequestsError
  | GetTemplateInfoForFilePathResult

type GetTemplateInfoForFilePathResult {
  originId: String!
  replReleaseId: String!
  language: String!
}

input GetTemplateInfoForFilePathInput {
  filePath: String!
}

union HostingMachineConfigurationsOutput =
    UnauthorizedError
  | HostingMachineConfigurationsResults

# Machine configurations available for hosting deployments.
type HostingMachineConfigurationsResults {
  results: [HostingMachineConfiguration!]
}

input HostingMachineConfigurationsInput {
  provider: HostingMachineConfigurationProvider!
}

type LanguageExamples {
  # A list of code examples
  examples: [LanguageExample!]!
}

type HostingDeploymentTemplatesResults {
  results: [HostingDeploymentTemplatesItem!]!
}

type HostingDeploymentTemplatesItem {
  repl: Repl!
  provider: HostingBuildProvider!
  language: String
}

input HostingDeploymentTemplatesInput {
  # Number of Repls to return. Maximum of 50
  count: Int = 10
}

union GitHubRepoSearchResult =
    UnauthorizedError
  | UserError
  | ServiceUnavailable
  | RepositoryConnection2

# A connection to a list of Repositories.
type RepositoryConnection2 {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of Repositorys.
  items: [Repository!]!
}

input RepositorySearchInput {
  # One or more search keywords
  query: String!

  # The GitHub owner to search under
  gitHubOwner: GitHubOwnerInput!

  # The cursor to continue from
  after: String

  # The number of results to return
  count: Int!
}

input GitHubOwnerInput {
  name: String!
  type: GitHubOwnerType!
}

enum GitHubOwnerType {
  User
  Organization
}

union CheckClientVersionQueryResult = CheckClientVersionOutput

type CheckClientVersionOutput {
  shouldReload: Boolean!
}

input CheckClientVersionInput {
  version: String!
}

union ScheduledJobListExecutionsOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | ScheduledJobListExecutionsResults

type ScheduledJobListExecutionsResults {
  results: [ScheduledJobExecution!]!
}

type ScheduledJobExecution {
  id: String!
  startedAt: DateTime!
  endedAt: DateTime
  status: ScheduledJobExecutionStatus!
}

enum ScheduledJobExecutionStatus {
  done
  running
  cancelled
  failed
  unrecognized
}

input ScheduledJobListExecutionsInput {
  # The deployment ID to list executions for
  deploymentId: String!
}

union GetEduExports = UserError | UnauthorizedError | GetEduExportsOutput

type GetEduExportsOutput {
  eduTeamExport: [EduTeamExports!]!
}

# A team export from the edu_team_exports table
type EduTeamExports {
  id: Int!
  teamId: Int!
  creatorUserId: Int!
  timeCreated: DateTime!
  timeUpdated: DateTime!
  runData: EduExportRunData!
  exportType: EduTeamExportType!
  status: EduTeamExportStatus!
}

type EduExportRunData {
  runs: [EduExportRun!]!
}

type EduExportRun {
  downloadUrl: String!
  downloadUrlExpiration: DateTime!
}

# Type of the export, who it's made by
enum EduTeamExportType {
  student
  teacher
}

# Status of the export
enum EduTeamExportStatus {
  not_started
  in_progress
  completed
  failed
}

input EduExportInputType {
  teamId: Int!

  # Who created the export, teacher or student?
  exportType: EduTeamExportType!
}

# The top level entry point for mutating the graph
type RootMutationType {
  # Marks a tour as seen
  markTourAsSeen(name: String!): TourSeen!
    @deprecated(reason: "Use markTourAsSeen2")

  # Marks a tour as seen
  markTourAsSeen2(input: MarkTourAsSeen2Input!): MarkTourAsSeen2Output!

  # Updates a Repl
  updateRepl(input: UpdateReplInput!): UpdateReplPayload!

  # Deletes a repl
  deleteRepl(id: String!): Repl!

  # Updates time_updated of a repl
  updateReplTimeUpdated(id: String!): UpdateReplTimeUpdatedOutput!
  createBoardReport(
    postId: Int
    commentId: Int
    replId: String
    reason: String!
    reportedUserId: Int
  ): BoardReport!
  reportBounty(bountyId: Int!, reason: String!): ReportBountyOutput!
  reportBountyApplication(
    bountyApplicationId: Int!
    reason: String!
  ): ReportBountyApplicationOutput!
  resolveBoardReport(id: Int!): BoardReport!
  unresolveBoardReport(id: Int!): BoardReport!
  createReplFolder(name: String!, parentId: String, teamId: Int): ReplFolder!
  deleteReplFolder(folderId: String!): ReplFolder!
  updateReplFolder(folderId: String!, name: String!): ReplFolder!
  moveItemsToFolder(
    replIds: [String]!
    folderIds: [String]!
    destFolderId: String!
    teamId: Int
  ): [DashboardItem!]!
  addMultiplayerUser(
    username: String!
    replId: String!
    type: String!
  ): ReplPermission!
  removeMultiplayerUser(username: String!, replId: String!): ReplPermission!

  # Marks all notifications as seen
  markAllNotificationsAsSeen: CurrentUser!

  # Marks all notifications as seen for a user
  markNotificationsAsSeen(
    # An optional list of IDs to be used to limit which notification are marked as seen
    ids: [Int!]
  ): Int!

  # Refreshes a multiplayer invite link
  refreshMultiplayerInviteLink(replId: String!): Repl!
  createMultiplayerInvite2(
    email: String!
    replId: String!
    type: String!
  ): MultiplayerInviteOutput!
  deleteMultiplayerInvite(
    email: String!
    replId: String!
  ): MultiplayerInviteOutput!

  # Updates the current user's email if allowed
  updateEmail(email: String!, password: String!): UpdateUserOutput

  # Unshares a shared repl with the current user
  removeSharedRepl(replId: String!): Repl!
  createRepl(
    input: CreateReplInput!
    isTitleAutoGenerated: Boolean
  ): CreateReplOutput!
  updateCurrentUser(input: UpdateCurrentUserInput!): CurrentUser

  # Updates the current user's password if allowed
  updatePassword(
    currentPassword: String!
    newPassword: String!
  ): UpdateUserOutput

  # Updates the current user's continent if allowed
  selectReplContinent(input: SelectReplContinentInput!): SelectReplContinent!

  # Updates the current user's role if allowed
  updateRole(
    # The role that is being changed - currently explorer is the only role that can be toggled
    role: UserRoles!

    # If true, the role will be added, and if false, the role will be removed
    flag: Boolean!
  ): UpdateUserOutput

  # ClUI root command
  clui: CluiMutation

  # Link a custom domain name to a repl
  linkReplDomain2(
    replId: String!
    domain: String!
    deploymentId: String
  ): LinkReplDomain2!
  createAnnotationAnchor(
    annotationAnchor: AnnotationAnchorInput!
    annotationMessage: AnnotationMessageInput
    highlight: AnnotationHighlightInput
  ): CreateAnnotationAnchorOutput
  createAnnotationMessage(
    replId: String!
    anchorId: String!
    annotationMessage: AnnotationMessageInput!
    highlight: AnnotationHighlightInput
  ): CreateAnnotationMessageOutput
  updateAnnotationAnchor(
    id: String!
    changes: AnnotationAnchorChangesInput!
  ): UpdateAnnotationAnchorOutput
  deleteTeam(input: DeleteTeamInput!): TeamOutput!
  updateTeam(input: UpdateTeamInput!): TeamOutput!
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberOutput!
  leaveTeam(teamId: Int!): LeaveTeamOutput!
  createTeamInvite(input: CreateTeamInviteInput!): CreateTeamInviteOutput!
  deleteTeamInvite(input: DeleteTeamInviteInput!): DeleteTeamInviteOutput!
  createTeamInviteLink(teamId: Int!): CreateTeamInviteLinkOutput!
  deleteTeamInviteLink(teamId: Int!): DeleteTeamInviteLinkOutput!
  updateTeamUserPermissions(
    input: UpdateTeamUserPermissionsInput!
  ): UpdateTeamUserPermissionsOutput!
  createReplTemplate(input: CreateReplTemplateInput!): CreateReplTemplateOutput!
  createReplAsTemplate(
    input: CreateReplAsTemplateInput!
  ): CreateReplAsTemplateOutput!
  updateReplTemplate(
    input: UpdateReplTemplateInput!
  ): UpdateReplTemplateOutputType!

  # ...
  submitRepl(replId: String!): SubmitReplOutput!

  # Lets a teacher unsubmit a Repl submission
  unsubmitRepl(replId: String!): UnsubmitReplOutput!

  # Mark a submission reviewed
  reviewRepl(replId: String!, status: Boolean!): ReviewReplOutput!

  # The mutation used to fork a project.
  createReplSubmission(templateId: Int!): CreateReplSubmissionOutput!
  createTemplateTest(input: CreateTemplateTestInput!): TemplateTestOutput!
  createReplUnitTest(input: CreateReplUnitTestInput!): ReplUnitTestOutput!
  deleteReplUnitTest(testId: Int!): ReplUnitTestOutput!
  updateReplUnitTest(input: UpdateReplUnitTestInput!): ReplUnitTestOutput!
  createReplUnitTestMeta(
    input: CreateReplUnitTestMetaInput!
  ): ReplUnitTestMetaOutput!
  updateReplUnitTestMeta(
    input: UpdateReplUnitTestMetaInput!
  ): ReplUnitTestMetaOutput!
  updateReplUnitTestLastRun(
    input: UpdateReplUnitTestLastRunInput!
  ): UpdateReplUnitTestLastRunOutput
  deleteTemplateTest(testId: Int!): DeleteReplTemplateOutput!
  updateTemplateTest(input: UpdateTemplateTestInput!): TemplateTestOutput!
  updateWorkspacePreferences(input: JSON!): CurrentUser!
  updateEditorPreferences(input: UpdateEditorPreferencesInput!): CurrentUser!
  createTeamInvitesFromCSV(input: CSVFileInput!): TeamOutput!
  createTemplateShareLink(teamId: Int!, templateIds: [Int!]!): Team!
  resetPrivacyStudentPassword(
    teamId: Int!
    userId: Int!
    password: String!
  ): ResetPrivacyStudentPasswordOutput!

  # The mutation used to get the templates from another team via the code of a template share link
  useTemplateShareLink(
    # The id of the team which the templates should be copied to
    teamId: Int!

    # The code of the link which we should copy templates from
    code: String!

    # The templates which should be taken from the link
    content: [Int!]!

    # Whether the timestamps for the templates should be copied or not
    withDates: Boolean!
  ): Int!

  # The mutation used to update a template share link for a team
  updateTemplateShareLink(
    # The id of the team which the link belongs to
    teamId: Int!

    # The id of the link which is to be updated.
    linkId: Int!
    templateIds: [Int!]!
  ): TeamTemplateShareLink!

  # The mutation used to delete a team's template share link
  deleteTemplateShareLink(
    # The id of the team which the link belongs to
    teamId: Int!

    # The id of the link which should be deleted
    linkId: Int!
  ): Team
  deleteProjectAndSubmissions(id: Int!): DeletedProjectAndSubmissionOutput!
  disconnectAuthProvider(provider: UserAuthProviders!): CurrentUser!
  createReplRelease(input: CreateReplReleaseInput!): CreateReplReleaseOutput!
  revertReplRelease(input: RevertReplReleaseInput!): RevertReplReleaseOutput!

  # Creates a deployment and release
  createReplDeployment(
    input: CreateReplDeployemntInput!
  ): CreateReplDeployemntOutput!
  deleteReplDeployment(
    input: DeleteReplDeploymentInput!
  ): DeleteReplDeploymentOutput!

  # Marks all messages in thread as read
  markMessagesAsSeen(
    replId: String!
    threadId: String
    messageIds: [String!]
  ): MarkMessagesAsSeenOutput

  # Deletes a user's account
  deleteAccount: Boolean!

  # Change conversation message preview in response to user input
  updateThreadPreview(
    threadId: String!
    messageId: String!
    message: String
  ): Boolean
  updateTeamOrganization(
    input: UpdateTeamOrganizationInput!
  ): UpdateTeamOrganizationOutput!
  saveIOTestResults(
    # The ID of the team which the Repl the results are for belongs to.
    teamId: Int!

    # The ID of the Repl which the test results are for.
    replId: String!

    # The results of the I/O tests executed on the Repl.
    results: [IOTestResultInput!]!
  ): SaveIOTestResultOutput

  # Updates a team member's nickname
  updateTeamMember(input: UpdateTeamMemberInput!): UpdateTeamMemberOutput!

  # Adds a new team to the organization, or adds a new free team if not associated with org.
  createTeamV2(input: CreateTeamV2Input!): CreateTeamV2Output!
  connectGoogleClassroom(
    input: ConnectGoogleClassroomInput!
  ): ConnectGoogleClassroomOutput
  deleteMultiplayerInviteLink(replId: String!): DeleteMultiplayerInviteLink!
  exportTeamSubmissions(teamId: Int!): ExportTeamSubmissionsOutput!
  disconnectGoogleClassroom(
    input: DisconnectGoogleClassroomInput!
  ): DisconnectGoogleClassroomOutput!

  # Creates a group project submission
  createReplSubmissionGroup(
    input: CreateReplSubmissionGroupInput!
  ): CreateReplSubmissionGroupOutput!

  # Creates a group project submission
  joinReplSubmissionGroup(
    input: JoinReplSubmissionGroupInput!
  ): JoinReplSubmissionGroupOutput
  exportProjectsOverview(
    input: ExportProjectsOverviewInput!
  ): ExportProjectsOverviewOutput!
  archiveTeam(input: ArchiveTeamInput!): ArchviveTeamInput!
  unarchiveTeam(input: UnarchiveTeamInput!): UnarchiveTeamOutput!
  setLanguageTemplateRepl(
    input: SetLanguageTemplateInput!
  ): SetLanguageTemplateOutput!
  createStack(input: CreateStackInput!): CreateStackOutput
  arrangeStackItem(input: ArrangeStackItemInput!): ArrangeStackItemOutput
  importCurriculum(input: ImportCurriculumInput!): ImportCurriculumOutput!
  updateStack(input: UpdateStackInput!): UpdateStackOutput!
  deleteStack(stackId: Int!): DeleteStackOutput!
  arrangeStack(input: ArrangeStackInput!): ArrangeStackOutput!
  createReplPost2(input: CreateReplPost2Input!): CreateReplPost2Output!
  unpublishReplFromCommunity(
    input: UnpublishReplFromCommunityInput!
  ): UnpublishReplFromCommunityOutput!
  giveCodexFeedback2(input: CodexFeedback2Input!): CodexFeedback2Output!
  toggleReplLike(input: ToggleReplLikeInput!): ToggleReplLikeOutput!
  setFollowing(input: setFollowingInput!): setFollowing
  setBlocking2(input: SetBlocking2Input!): SetBlocking2!
  setTemplateReplCategory(
    input: SetTemplateReplCategoryInput!
  ): SetTemplateCategoryOutput!
  setOnboardingTraits(
    skillLevel: OnboardingExperience!
    userType: Intent!
  ): SetOnboardingTraitsOutput!

  # Creates a model solution for a project
  createReplTemplateModelSolution(
    input: CreateReplTemplateModelSolutionInput!
  ): CreateReplTemplateModelSolutionOutput!

  # Creates a model solution fork for students to view and edit
  createReplTemplateModelSolutionFork(
    input: CreateReplTemplateModelSolutionForkInput!
  ): CreateReplTemplateModelSolutionForkOutput!

  # Creates a model solution for a project
  updateReplTemplateModelSolution(
    input: UpdateReplTemplateModelSolutionInput!
  ): UpdateReplTemplateModelSolutionOutput!
  updateTeamOrganizationMember(
    input: UpdateTeamOrganizationMemberInput!
  ): UpdateTeamOrganizationMemberOutput!
  deleteTeamOrganizationMember(
    input: DeleteTeamOrganizationMemberInput!
  ): DeleteTeamOrganizationMemberOutput!
  deleteTeamOrganization(
    input: DeleteTeamOrganizationInput!
  ): DeleteTeamOrganizationOutput!
  createTeamOrganizationInvite(
    input: CreateTeamOrgInviteInput!
  ): CreateTeamOrgInviteOutput!
  deleteTeamOrganizationInvite(
    input: DeleteTeamOrgInviteInput!
  ): DeleteTeamOrgInviteOutput!
  updateSubscription(input: UpdateSubscriptionInput!): UpdateSubscription!
  createTeamOrgInviteLink(orgId: Int!): CreateTeamOrgInviteLinkOutput!
  deleteTeamOrgInviteLink(orgId: Int!): DeleteTeamOrgInviteLinkOutput!
  copyTeamTemplate(input: CopyTeamTemplateInput!): CopyTeamTemplateOutput!
  copyStacksToTeam(input: CopyStacksToTeamInput!): CopyStacksToTeamOutput!
  joinTeamAsOrgAdmin(teamId: Int!): JoinTeamAsOrgAdminOutput!
  setUserSocials(input: SetUserSocialsInput!): SetUserSocialsOutput!
  updateUserSitePresence: UpdateUserSitePresenceOutput!
  updateUserPrivacyPreferences(
    input: UpdateUserPrivacyPreferencesInput!
  ): UpdateUserPrivacyPreferencesOutput!
  setUserCoverImage(input: SetUserCoverImageInput!): SetUserCoverImageOutput!
  createTheme(input: CreateThemeInput!): CreateThemeOutput!
  updateTheme(input: UpdateThemeInput!): UpdateThemeOutput!
  publishTheme(input: PublishThemeInput!): PublishThemeOutput!
  unpublishTheme(input: UnpublishThemeInput!): UnpublishThemeOutput!
  unpublishThemeAsModerator(
    input: UnpublishThemeAsModeratorInput!
  ): UnpublishThemeAsModeratorOutput!
  installTheme(input: InstallThemeInput!): InstallThemeOutput!
  uninstallTheme(input: UninstallThemeInput!): UninstallThemeOutput!
  deleteTheme(input: DeleteThemeInput!): DeleteThemeOutput!
  upgradeTheme(input: UpgradeThemeInput!): UpgradeThemeOutput!
  setActiveTheme(input: SetActiveThemeInput!): SetActiveThemeOutput
  reportCustomTheme(
    customThemeId: Int!
    customThemeVersionId: Int!
    reason: String!
  ): ReportCustomThemeOutput!
  toggleHiddenPost(postId: Int!, isHidden: Boolean!): ToggleHiddenPostOutput!
  importGithubRepo(input: ImportGithubRepoInput!): ImportGithubRepoOutput!

  # Warn a user
  warnUser(username: String!, reason: String!): WarnUserOutput!

  # Remove a warning from a user
  removeWarn(username: String!, warnId: Int!): RemoveWarnOutput!

  # Ban a user from community.
  banCommunityUser(
    username: String!
    reason: String!
    timeExpired: DateTime
  ): BanCommunityUserOutput!
  setReplLayoutState(input: SetReplLayoutStateInput!): SetReplLayoutStateOutput!
  setReplTags(input: SetReplTagsInput!): SetReplTagsOutput!

  # Sets the settings that control the repl view outside the workspace.
  setReplViewSettings(
    input: SetReplViewSettingsInput!
  ): SetReplViewSettingsOutput!
  createTeacherVerificationResponse(
    input: CreateTeacherVerificationResponseInput!
  ): CreateTeacherVerificationResponseOutput!

  # Escalate a report for admins to review.
  escalateBoardReport(id: Int!): EscalateBoardUserOutput!

  # Review a Template to either promote or demote it from the create Repl form
  reviewTemplate(input: ReviewTemplateInput!): ReviewTemplateOutput!

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found.This mutation is maintained for backwards compatibility with themobile app, prefer updatePrivatePowerUp2 instead for new implementations.
  updatePrivatePowerUp(active: Boolean!): UpdatePrivatePowerUpOutput!

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found.Unlike its legacy equivalent, returns a currentUser type so thatclients can fetch updated balance, power ups, etc as part of the mutation.
  updatePrivatePowerUp2(active: Boolean!): UpdatePrivatePowerUp2Output!

  # Deletes all community bans on a user.
  unbanCommunityUser(input: UnbanCommunityUserInput!): UnbanCommunityUserOutput!

  # Unpublish a user's repl from the community and notify the user.
  moderatorUnpublish(input: ModeratorUnpublishInput!): ModeratorUnpublishOutput!
  createUserCourse(input: CreateUserCourseInput!): CreateUserCourseOutput
  createUserCourseLesson(
    input: CreateUserCourseLessonInput!
  ): CreateUserCourseLessonOutput
  completeUserCourseLesson(
    input: CompleteUserCourseLessonInput!
  ): UpdateUserCourseLessonOutput
  restartUserCourseLesson(
    input: RestartUserCourseLessonInput!
  ): RestartUserCourseLessonOutput
  setTemplateCategoryRepl(
    input: SetTemplateCategoryReplInput!
  ): SetTemplateCategoryReplOutput
  unsetTemplateCategoryRepl(
    input: UnsetTemplateCategoryReplInput!
  ): UnsetTemplateCategoryReplOutput

  # Sends a user an in-app notification from a moderator or an admin.
  moderatorNotification(
    input: ModeratorNotificationInput!
  ): ModeratorNotificationOutput!
  createBounty(input: CreateBountyInput!): CreateBountyOutput!
  editBounty(input: EditBountyInput!): EditBountyOutput!

  # Cancels a Bounty by refunding the poster, marking the status as closed and unlisting the bounty
  cancelBounty(input: CancelBountyInput!): CancelBountyOutput!
  createBountyApplication(
    input: CreateBountyApplicationInput!
  ): CreateBountyApplicationOutput!
  createBountySubmission(
    input: CreateBountySubmissionInput!
  ): CreateBountySubmissionOutput!
  createBountySubmissionReview(
    input: CreateBountySubmissionReviewInput!
  ): CreateBountySubmissionReviewOutput!
  reviewBountyApplication(
    input: ReviewBountyApplicationInput!
  ): ReviewBountyApplicationOutput!
  moderateBountyApplication(
    input: ModerateBountyApplicationInput!
  ): ModerateBountyApplicationOutput!
  setBountyUnlisted(
    bountyId: Int!
    isUnlisted: Boolean!
  ): SetBountyUnlistedOutput!
  forceSolverToAbandonBountyAsStaff(
    input: ForceSolverToAbandonBountyAsStaffInput!
  ): ForceSolverToAbandonBountyAsStaffOutput!
  cancelBountyAsStaff(
    input: CancelBountyAsStaffInput!
  ): CancelBountyAsStaffOutput!

  # Allows a Bounty hunter to abandon a Bounty for which they have been accepted
  abandonBounty(input: AbandonBountyInput!): AbandonBountyOutput!
  removeBountyApplicationAsModerator(
    input: RemoveBountyApplicationAsModeratorInput!
  ): RemoveBountyApplicationAsModeratorOutput!
  removeBountyApplicationAsApplicant(
    input: RemoveBountyApplicationAsApplicantInput!
  ): RemoveBountyApplicationAsApplicantOutput!
  reviewBountyHunter(input: ReviewBountyHunterInput!): ReviewBountyHunter!
  removeBountyHunterReviewAsStaff(
    input: RemoveBountyHunterReviewAsStaffInput!
  ): RemoveBountyHunterReviewAsStaffOutput!
  sendBountyChat(input: SendBountyChatInput!): SendBountyChatOutput!
  markBountyChatRead(input: MarkBountyChatReadInput!): MarkBountyChatReadOutput!
  hireBountyHunterService(
    input: HireBountyHunterServiceInput!
  ): HireBountyHunterServiceOutput!

  # Creates a hosted Stripe checkout session for a Cycles purchase which the caller can redirect the user to
  createCyclesStripeCheckoutSession(
    input: CreateCyclesStripeCheckoutSessionInput!
  ): createCyclesStripeCheckoutSession
  bulkModerate(input: BulkModerateInputArg!): BulkModerateOutput

  # When `active` is true, either find and update an existing order or charge the user and create a new one. When `active` is false, either update an existing order or return an error if none is found
  updateGhostwriterPowerUp(
    input: UpdateGhostwriterPowerUpInput!
  ): UpdateGhostwriterPowerUpOutput!

  # Creates a Neon database for the given user and repl
  createNeonDatabase(input: CreateNeonDatabaseInput!): CreateNeonDatabaseOutput!

  # Deletes a Neon database
  deleteNeonDatabase(input: DeleteNeonDatabaseInput!): DeleteNeonDatabaseOutput!

  # Freezes a Neon database
  freezeNeonDatabase(input: FreezeNeonDatabaseInput!): FreezeNeonDatabaseOutput!

  # Unfreezes a Neon database
  unfreezeNeonDatabase(
    input: UnfreezeNeonDatabaseInput!
  ): UnfreezeNeonDatabaseOutput!
  failHostingBuild(input: FailHostingBuildInput!): FailHostingBuildOutput

  # Boost a Repl
  boostRepl2(input: BoostRepl2Input!): BoostRepl2Output!

  # Resolves an image scan.
  resolveImageScan(imageScanClassificationId: Int!): ImageScanType!
  registerPushDeviceSession(
    input: RegisterPushDeviceSessionInput!
  ): RegisterPushDeviceSessionOutput!
  unregisterPushDeviceSession(
    input: UnregisterPushDeviceSessionInput!
  ): UnregisterPushDeviceSessionOutput!

  # Install an extension. If replId is not provided, the extension will be installed to the user
  installExtension(
    extensionId: String!
    replId: String
  ): InstallExtensionOutput!

  # Add a Repl that can authorize as its owner using Repl Identity
  addReplIdentityAllowedRepl(
    input: AddReplIdentityAllowedReplInput!
  ): AddReplIdentityAllowedRepl!

  # Remove an authorized Repl so it can no longer authorize as its owner using Repl Identity
  deleteReplIdentityAllowedRepl(
    input: DeleteReplIdentityAllowedReplInput!
  ): DeleteReplIdentityAllowedRepl!

  # Remove an extension installation
  uninstallExtension(installationId: String!): UninstallExtensionOutput!
  deployHostingBuild2(
    input: DeployHostingBuild2Input!
  ): DeployHostingBuild2Output

  # Send a push notification to all staff users
  sendPushToStaff(input: SendPushToStaffInput!): SendPushToStaff!
  deleteThreadMessage(messageId: String!): DeleteThreadMessageOutput

  # Change the user's subscription
  changeSubscription(input: ChangeSubscriptionInput!): ChangeSubscriptionOutput!

  # Remove a user's  profile picture or cover image
  adminRemoveUserImage(
    username: String!
    reason: String!
    deleteProfilePicture: Boolean
    deleteCoverImage: Boolean
  ): AdminRemoveUserImageOutput!

  # Create a setup intent for the requesting user. Use this to save a payment method for future use.
  createSetupIntent(input: CreateSetupIntentInput): CreateSetupIntentOutput!

  # Update the Auto-Refill configuration for the requesting user.
  updateCyclesAutoRefillConfiguration(
    input: UpdateCyclesAutoRefillConfigurationInput!
  ): UpdateCyclesAutoRefillConfigurationOutput!

  # Stores the ID for an App Store transaction if one doesn't already exist
  getOrCreateAppStoreCustomer: AppStoreCustomerOutput!

  # Stores the ID for an App Store transaction if one doesn't already exist
  getOrCreatePlayStoreCustomer: PlayStoreCustomerOutput!

  # Create a Replit Checkout Session for a one-time purchase. The clientSecret must be used to submit to Stripe using stripe.js to complete the purchase. One side effect of this mutation is that it will update the user's payment method to the one that is currently saved in Stripe if they haven't saved a payment method in Replit.
  createReplitOneTimeCheckoutSession(
    input: CreateReplitOneTimeCheckoutSessionInput!
  ): CreateReplitOneTimeCheckoutSessionOutput!

  # Create a Replit Checkout Session for a plan subscription. The clientSecret must be used to submit to Stripe using stripe.js to complete the purchase. One side effect of this mutation is that it will update the user's payment method to the one that is currently saved in Stripe if they haven't saved a payment method in Replit.
  createReplitPlanCheckoutSession(
    input: CreateReplitPlanCheckoutSessionInput!
  ): CreateReplitPlanCheckoutSessionOutput!

  # Remove a repl's icon image as an administrator.
  adminRemoveReplIcon(
    replUrl: String!
    reason: String!
  ): AdminRemoveReplIconOutput!

  # Remove a repl's cover image as an administrator.
  adminRemoveCoverImage(
    replUrl: String!
    reason: String!
  ): adminRemoveCoverImageOutput!

  # Creates a Repository on GitHub
  createGithubRepo(input: CreateGithubRepoInput!): CreateGithubRepoOutput!

  # Set a Repls Hosting Tier
  setHostingTier(input: SetHostingTierInput!): SetHostingTierOutput!

  # Send a deployment lifecycle command
  sendDeploymentLifecycleCommand(
    input: SendDeploymentLifecycleCommandInput!
  ): SendDeploymentLifecycleCommandOutput!

  # Updates an existing extension
  updateExtension(
    # The extension's ID
    extensionId: String!

    # The extension's new name
    name: String

    # The extension's new description
    description: String

    # The extension's new slug
    slug: String
  ): UpdateExtensionOutput!
  setUserKeybindings(input: SetUserKeybindingsInput!): SetUserKeybindingsOutput!

  # Creates a new extension
  createExtension(
    name: String!
    description: String!
    url: String
  ): CreateExtensionOutput!

  # Tries to complete a subscription purchase made in the Google Play Store
  completeGoogleSubscriptionPurchase(
    packageName: String!
    purchaseToken: String!
    purchaseInfo: String
  ): CompleteGoogleSubscriptionPurchaseOutput!

  # Tries to complete a subscription purchase made in the Apple Play Store
  completeAppleSubscriptionPurchase(
    appId: String!
    originalTransactionId: String!
    purchaseInfo: String
  ): CompleteAppleSubscriptionPurchaseOutput!
  setExtensionListed(
    extensionId: String!
    isListed: Boolean!
  ): SetExtensionListedOutput!
  setExtensionBlessed(
    extensionId: String!
    isBlessed: Boolean!
  ): SetExtensionBlessedOutput!
  setExtensionFeatured(
    extensionId: String!
    isFeatured: Boolean!
  ): SetExtensionFeaturedOutput!

  # Deletes multiple repls
  batchDeleteRepls(input: BatchDeleteReplsInput!): BatchDeleteReplsOutput!
  frontSupportRequest(
    input: FrontSupportRequestInput!
  ): FrontSupportRequestOutput!

  # Updates (enables/disables) a home page module
  updateHomeModule(input: UpdateHomeModuleInput!): UpdateHomeModuleOutput!
  checkClientVersion(input: CheckClientVersionInput!): CheckClientVersionResult!

  # Link a custom domain name to a hosting deployment
  linkHostingDeploymentDomain(
    input: LinkHostingDeploymentDomainInput!
  ): LinkHostingDeploymentDomain!

  # Unlink a custom domain name from a hosting deployment
  unlinkHostingDeploymentDomain(
    input: UnlinkHostingDeploymentDomainInput!
  ): UnlinkHostingDeploymentDomain!

  # Unlink a custom domain name from a hosting deployment
  unlinkLegacyReplDomain(
    input: UnlinkLegacyReplDomainInput!
  ): UnlinkLegacyReplDomain!

  # Allows a user to give feedback on a workflow
  giveWorkflowFeedback(
    input: WorkflowFeedbackInputType!
  ): WorkflowFeedbackOutput!

  # Verifes a custom domain for a hosting deployment
  verifyHostingDeploymentDomain(
    input: VerifyHostingDeploymentDomainInput!
  ): VerifyHostingDeploymentDomain!

  # Deletes an extension
  deleteExtension(extensionId: String!): DeleteExtensionOutput!
  sendSmsVerification(
    input: SendSmsVerificationInput!
  ): SendSmsVerificationOutput!
  confirmSmsVerification(
    input: ConfirmSmsVerificationInput!
  ): ConfirmSmsVerificationOutput!
  changeUsername(input: ChangeUsernameInput!): ChangeUsernameOutput!

  # Update the usage-based billing budget for the requesting user.
  updateUsageBasedBillingBudget(
    input: UpdateUsageBasedBillingBudgetInput!
  ): UpdateUsageBasedBillingBudgetOutput!

  # Creates a new user user workspace layout
  createUserWorkspaceLayout(
    input: CreateUserWorkspaceLayoutInput!
  ): CreateUserWorkspaceLayoutOutput!

  # Updates a workspace layout
  updateUserWorkspaceLayout(
    input: UpdateUserWorkspaceLayoutInput!
  ): UpdateUserWorkspaceLayoutOutput!

  # Deletes a workspace layout
  deleteUserWorkspaceLayout(
    input: DeleteUserWorkspaceLayoutInput!
  ): DeleteUserWorkspaceLayoutOutput!

  # Saves UserAuth state to the user's account
  saveUserAuth(input: SaveUserAuthInput!): SaveUserAuthOutput!

  # Set the trial billing period for the current user (yearly or monthly)
  setTrialBillingPeriod(
    input: SetTrialBillingPeriodInput!
  ): SetTrialBillingPeriodOutput!

  # Report an extension
  reportExtension(
    extensionId: String!
    reportMessage: String!
  ): ReportExtensionOutput!

  # Claim the annual promotion by immediately changing the plan.
  claimAnnualPromotion: ClaimAnnualPromotionOutput!
  deployExtension2(
    extensionId: String!
    replId: String!
    outputDirectory: String!
    buildCommand: String!
  ): DeployExtension2Output!

  # Add a public SSH key to the user's account
  addPublicSshKey(input: AddPublicSshKeyInput!): AddPublicSshKeyResult

  # Delete a public SSH key to the user's account
  deletePublicSshKey(input: DeletePublicSshKeyInput!): DeletePublicSshKeyResult
  createBucket(input: CreateBucketInput!): CreateBucketOutput!
  deleteBucket(input: DeleteBucketInput!): DeleteBucketOutput!

  # Add an existing user or invite a non-user to a Repl via email
  addOrInviteReplMultiplayer(
    input: AddOrInviteReplMultiplayerInput!
  ): AddOrInviteReplMultiplayerResult!
  updateTeamReplPresence(input: UpdateTeamReplPresenceInput!): Boolean

  # Create a custom group inside of an organization.
  createOrgGroup(input: CreateOrgGroupInput!): CreateOrgGroupOutput!

  # Remove a member from an organization.
  removeOrgMember(input: RemoveOrgMemberInput!): RemoveOrgMemberOutput!

  # Delete an org and its associated resources.
  deleteOrg(input: DeleteOrgInput!): DeleteOrgOutput!
  exportTeamsEduTeacher(teamId: Int!): ExportTeamsEduTeacherOutput!
  exportTeamsEduStudent(teamId: Int!): ExportTeamsEduStudentOutput!

  # Add an existing organization member to an org group.
  addOrgGroupMember(input: AddOrgGroupMemberInput!): AddOrgGroupMemberOutput!

  # Remove a member from an org group.
  removeOrgGroupMember(
    input: RemoveOrgGroupMemberInput!
  ): RemoveOrgGroupMemberOutput!

  # Add a user to the organization, or send an invite via email.
  addOrInviteOrgMember(
    input: AddOrInviteOrgMemberInput!
  ): AddOrInviteOrgMemberOutput!
  cancelScheduledJobExecution(
    input: CancelScheduledJobExecutionInput!
  ): CancelScheduledJobExecutionOutput!
  executeScheduledJob(
    input: ExecuteScheduledJobInput!
  ): ExecuteScheduledJobOutput!

  # Update a group inside of an organization.
  updateOrgGroup(input: UpdateOrgGroupInput!): UpdateOrgGroupOutput!

  # Update the permissions for a group.
  updateOrgGroupScopes(
    input: UpdateOrgGroupScopesInput!
  ): UpdateOrgGroupScopesOutput!

  # Delete a group inside of an organization.
  deleteOrgGroup(input: DeleteOrgGroupInput!): DeleteOrgGroupOutput!
  updateReplGitState(input: UpdateReplGitStateInput!): UpdateReplGitStateOutput!

  # Update org profile.
  updateOrgProfile(input: UpdateOrgProfileInput!): UpdateOrgProfileOutput!
  createProject(input: CreateProjectInput!): CreateProjectOutput!

  # Deletes a Project
  deleteProject(input: DeleteProjectInput!): DeleteProjectOutput!
  setFiletypeAssociation(
    input: FiletypeAssociationInput!
  ): SetFiletypeAssociationOutput

  # Create a setup intent for the requesting user. Use this to save a payment method for future use.
  createOrgSetupIntent(
    input: CreateOrgSetupIntentInput!
  ): CreateOrgSetupIntentOutput!

  # Accept an org invitation.
  acceptOrgInvite(input: AcceptOrgInviteInput!): AcceptOrgInviteOutput!
  pingOrgReplPresenceSession(input: PingOrgReplPresenceSessionInput!): Boolean

  # Update org Context.
  updateOrgContext(input: UpdateOrgContextInput!): UpdateOrgContextOutput
}

union MarkTourAsSeen2Output = UserError | UnauthorizedError | TourSeen

input MarkTourAsSeen2Input {
  name: String!
}

type UpdateReplPayload {
  repl: Repl!
}

input UpdateReplInput {
  id: String!
  title: String
  description: String
  imageUrl: String
  iconUrl: String
  isPrivate: Boolean
  isStarred: Boolean
  language: String
  templateLabel: String
  isServer: Boolean
  isExtension: Boolean
  isVnc: Boolean
  removeDomain: String
  doClone: Boolean
}

union UpdateReplTimeUpdatedOutput = UserError | NotFoundError | Repl

union ReportBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union ReportBountyApplicationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union DashboardItem = Repl | ReplFolder

union MultiplayerInviteOutput = MultiplayerInvite | ReplPermission | UserError

union UpdateUserOutput = CurrentUser | UserError

union CreateReplOutput = UserError | Repl

input CreateReplInput {
  title: String
  description: String
  language: String
  folderId: String
  gitRemoteUrl: String
  originId: String
  replReleaseId: String
  isPrivate: Boolean
  forkToPersonal: Boolean
  teamId: Int
  stackId: Int
  claimSource: String
  disableBetaTemplates: Boolean
  orgId: String
}

input UpdateCurrentUserInput {
  firstName: String
  lastName: String
  bio: String
  location: String
  profileImageId: Int
  emailNotifications: Boolean
  marketingNotifications: Boolean
}

union SelectReplContinent =
    UnauthorizedError
  | NotFoundError
  | UserError
  | ServiceUnavailable
  | TooManyRequestsError
  | CurrentUser

# Input for the selectReplContinent mutation.
input SelectReplContinentInput {
  continent: ReplContinentId!
}

type CluiMutation {
  # Admin CLUI operations
  admin: AdminCluiMutation

  # Staff CLUI operations
  staff: StaffCluiMutation

  # Manage your account
  account: UserCliAccountMutation

  # Moderator CLUI operations
  moderator: ModeratorCluiMutation

  # List and restore deleted repls and folders
  trash: TrashMutation

  # View and manage your teams
  team: TeamMutation

  # View and manage extensions you've made
  extension: ExtensionMutation
}

type AdminCluiMutation {
  # View, impersonate, ban, etc.
  user: AdminCliUserMutation

  # Manage user roles
  roles: AdminCliRolesMutation

  # Provision a team
  team: AdminTeamMutation

  # Manage site banner
  banners: AdminCliBannersMutation

  # Set app wide key/value
  appEnv: AdminCliAppEnvMutation

  # Poison, cleanse, etc.
  repl: AdminCliReplMutation

  # Configure templates
  templates: AdminCliTemplatesMutation

  # View and publish curriculum hub content
  curriculum: AdminCurriculumHubMutation

  # Delete, Suspend, Resume, etc.
  hostingDeployment: AdminCliHostingDeploymentsMutation

  # Configure organizations
  org: AdminCliBillingOrgsMutation

  # Configure subscriptions
  subscriptions: AdminCliSubscriptionsMutation

  # View and update manually curated content for trending
  curation: ManualCurationMutation

  # View and manage extensions on Replit
  extension: AdminCliExtensionMutation

  # Run an export of a edu team's data.
  exportEdu: AdminEduExportMutation

  # View, Delete, etc.
  cloudServices: AdminCliCloudServicesMutation

  # Send notification to a user
  notifications: AdminCliNotificationsMutation
}

type AdminCliUserMutation {
  # This does terrible things to a user's account. This is not a Repl Talk ban, this is a SITE WIDE BAN. All their Repls go poof and they will no longer be able to access their account.
  ban(
    # User's username or email
    user: String!

    # Reason for ban
    reason: String!
  ): CluiOutput

  # This makes everything better again. This is not a repl talk unban, this is a SITE WIDE UNBAN. All their repls come back and they will have to access their account again.
  unban(
    # User's username or email
    user: String!

    # set the first name of the user
    firstName: String!

    # set the last name of the user
    lastName: String!

    # Defaults to user_bans.time_created; can force restore repls deleted after time (2021-12-31T23:59:59.999Z in UTC)
    time: String
  ): CluiOutput

  # Restore a users account and their repls
  restore(
    # User's username or email
    user: String!

    # (optional) force restore repls by this time (2021-12-31T23:59:59.999Z in UTC)
    time: String
  ): CluiOutput

  # Change a users email
  changeEmail(
    # User's username or email
    user: String!

    # set the email of the user
    email: String!
  ): CluiOutput

  # Change a users username
  changeUsername(
    # User's username or email
    user: String!

    # set the username of the user
    username: String!
  ): CluiOutput

  # Impersonate a user via passing in their username and email. This will log you in as that user. This should be a last resort option because this is not an invisible action (e.g. if you open a Repl, the user may be logged in and see you moving around their files), and it is very easy to mess something up for the user. Please review the guidelines in our impersonation policy doc here: https://docs.google.com/document/d/1y014MLai3CMeYgeLeRnC6Dki09TC-6hFyXUOpk4TMT0
  impersonate(
    # User's username or email
    user: String!
  ): CluiOutput

  # Modify a user's trust level
  trust(
    # User's username or email
    user: String!

    # Desired trust level; empty removes the trust level
    level: UserTrustEnum
  ): CluiOutput

  # Override a user's default cluster
  cluster(
    # User's username or email
    user: String!

    # Override cluster; empty removes the override.
    cluster: String

    # Transfer user's existing Repls to the new cluster. If false, the user's Repls will remain in the old cluster and new Repls will be created in the new cluster.
    transferRepls: Boolean

    # Create override even if cluster name is not known. This is useful for creating overrides for clusters that are not yet known to the system.
    forceCluster: Boolean
  ): CluiOutput

  # Provisions a trial subscription to Core for a set amount of time
  provision(
    # Username or email of existing user, or a comma-separated list of usernames (up to 500)
    username: String!

    # Duration of trial subscription (in months)
    months: Int!
  ): CluiOutput

  # Expires a user subscription
  deprovision(
    # Username or email of existing user
    username: String!
  ): CluiOutput

  # Mark the user as email verified
  verify(
    # Username or email of existing user
    username: String!
  ): CluiOutput

  # View and manage users' Cycles balances
  cycles: AdminCliUserCyclesMutation

  # View and manage users' PowerUps
  powerUps: AdminCliUserPowerUpsMutation

  # View and manage users' IAP subscriptions
  iap: AdminCliUserIAPMutation

  # Manage usage-based billing for users.
  usageBasedBilling: AdminCliUserUsageBasedBillingMutation

  # View and manage user's storage
  storage: AdminCluiUserStorageMutation

  # Manage SMS verification for users.
  smsVerification: AdminCliUserSmsVerificationMutation

  # Manage Firebase User IDs (fuids)
  fuid: AdminCliUserFuidMutation

  # Manage Stripe subscriptions
  stripe: AdminCliStripeMutation
}

enum UserTrustEnum {
  low
}

type AdminCliUserCyclesMutation {
  # Retire cycles from a user. Please read these guidelines first: https://replit.com/@util/handbook#cycles/clui_rules.md
  retire(
    # The username or email of the user
    username: String!

    # The number of cycles to retire.
    cycles: Int!

    # The reason for retiring cycles.
    internalComment: String!
  ): CluiOutput

  # Grant cycles to a user. Please read these guidelines first: https://replit.com/@util/handbook#cycles/clui_rules.md
  grant(
    # The username or email of a single user, or a comma-separated list of user IDs (up to 100).
    target: String!

    # The number of cycles to grant.
    cycles: Int!

    # The reason for granting cycles.
    internalComment: String!
  ): CluiOutput

  # Manage a user's Cycles for cash out
  cashOut: AdminCliUserCyclesCashOutMutation
}

type AdminCliUserCyclesCashOutMutation {
  # Pledge Cycles to be cashed out for a user.
  pledge(
    # The username or email of the user cashing out cycles
    user: String!

    # The number of Cycles to pledge for cash out
    cycles: Int!

    # The percent of the Cycles Replit will charge as a fee for cash out.
    feePercent: CashOutFeePercentEnum!
  ): CluiOutput

  # Resolve the cash out process by recording a wallet's pledged Cycles as paid.
  paid(
    # The username or email of the user cashing out cycles
    user: String!
  ): CluiOutput

  # Resolve the cash out process by refunding a user their pledged Cycles.
  refund(
    # The username or email of the user cashing out cycles
    user: String!
  ): CluiOutput
}

enum CashOutFeePercentEnum {
  default
  fifteen
}

type AdminCliUserPowerUpsMutation {
  # Create a Power Ups trial for a user (assuming one doesn't exist yet)
  createTrial(
    # Usernames or emails, separated by commas
    user: String!

    # The type of Power Up
    powerUp: PowerUpTrialTypeEnumType!

    # The expiry date to set for the trial (used as an input to new Date() JavaScript call)
    expiry: String!
  ): CluiOutput

  # Edit Power Ups trials for a user (assumes one exists)
  editTrial(
    # The username or email of the user
    user: String!

    # The type of Power Up
    powerUp: PowerUpTrialTypeEnumType!

    # The expiry date to set for the trial (used as an input to new Date() JavaScript call)
    expiry: String!
  ): CluiOutput
}

enum PowerUpTrialTypeEnumType {
  ghostwriter
  private
}

type AdminCliUserIAPMutation {
  # Create an IAP subscription for a user (if one doesn't exist yet). 1 month duration.
  createIAPSubscription(
    # The username or email of the user
    user: String!

    # The plan id (defaults to current Pro plan)
    planId: String

    # The provider name (defaults to apple)
    providerName: String
  ): CluiOutput

  # Expire an IAP subscription for a user (if one exists).
  expireIAPSubscriptions(
    # The username or email of the user
    user: String!
  ): CluiOutput

  # Sync an In-App Purchase subscription.
  syncIAPSubscription(
    # The originalTransactionId (iOS) or purchaseToken (Android) of the subscription purchase
    subscriptionExternalId: String!

    # The payment provider
    paymentProvider: PaymentProvider!
  ): CluiOutput
}

enum PaymentProvider {
  google
  apple
}

type AdminCliUserUsageBasedBillingMutation {
  # Ingest fake Autoscale Deployment compute units usage data for a user. This is useful for testing and debugging and should NOT be used for real users.
  ingestAutoscaleUsage(
    # The username or email of a single user
    target: String!

    # The number of seconds of usage to ingest.
    usageSeconds: Int!

    # repl ID
    repl: String!
  ): CluiOutput

  # Ingest fake Deployments Egress usage data for a user. This is useful for testing and debugging and should NOT be used for real users.
  ingestDeploymentsEgress(
    # The username or email of a single user
    target: String!

    # The number of MiB of usage to ingest.
    usageMib: Int!

    # repl ID
    repl: String!
  ): CluiOutput

  # Ingest fake Autoscale Incoming Requests usage data for a user. This is useful for testing and debugging and should NOT be used for real users.
  ingestAutoscaleRequests(
    # The username or email of a single user
    target: String!

    # The number of requests to ingest.
    usageRequestCount: Int!

    # repl ID
    repl: String!
  ): CluiOutput

  # Ingest fake dev resource usage data for a user. This is useful for testing and debugging and should NOT be used for real users
  ingestDevUsage(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!

    # MiB of dev egress to ingest
    egressBytesMib: Int!

    # The tier of dev compute to ingest
    computeTier: FakeDevComputeTier!

    # The number of seconds of usage to ingest
    usageSeconds: Int!
  ): CluiOutput

  # Ingest fake Modelfarm usage data for a user. This is useful for testing and debugging and should NOT be used for real users.
  ingestModelfarmUsage(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!

    # The model name
    model: String!

    # The provider name
    provider: String!

    # The number of billable input characters. Defaults to 0.
    billableInputCharacters: Int

    # The number of billable output characters. Defaults to 0.
    billableOutputCharacters: Int

    # The number of billable input tokens. Defaults to 0.
    billableInputTokens: Int

    # The number of billable output tokens. Defaults to 0.
    billableOutputTokens: Int
  ): CluiOutput

  # Ingest fake dev storage usage data for a user. This is useful for testing and debugging and should NOT be used for real users
  ingestDevStorageUsage(
    # The username or email of a single user, or the ID of an org
    target: String!

    # Optional Org Id to attribute usage to instead of the target user
    orgId: String

    # Bytes of dev storage to ingest. String to workaround GraphQL max integer
    storageBytes: String!
  ): CluiOutput

  # Ingest fake Neon Compute Time, Data Storage, Written Data & Data Transfer usage data for a user. This is useful for testing and debugging and should NOT be used for real users
  ingestNeonUsage(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!

    # The number of seconds of Compute Time usage to ingest
    computeTime: Int!

    # The number of bytes of Data Storage usage to ingest
    dataStorage: Int!

    # The number of bytes of Written Data usage to ingest
    writtenData: Int!

    # The number of bytes of Data Transfer usage to ingest
    dataTransfer: Int!
  ): CluiOutput

  # Ingest fake Reserved VM compute time usage data for a user. This is useful for testing and debugging and should NOT be used for real users
  ingestReservedVMUsage(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!

    # The hosting tier to ingest
    hostingTier: HostingTierPowerUpSku!

    # The number of seconds of usage to ingest
    usageSeconds: Int!
  ): CluiOutput

  # Ingest fake Scheduled Deployment compute units and/or scheduler usage data for a user. This is useful for testing and debugging and should NOT be used for real users.
  ingestScheduledJobUsage(
    # The username or email of a single user
    target: String!

    # The number of seconds of usage to ingest. If non provided, usage won't be ingested.
    usageSeconds: Int

    # The number of scheduler events to ingest. 1 event is equivalent to a 24 hour period of usage. If non provided, usage won't be ingested.
    schedulerEvents: Int

    # repl ID
    repl: String!
  ): CluiOutput

  # Ingest fake Object Storage usage data for a user. This is useful for testing and debugging and should NOT be used for real users
  ingestObjectStorageUsage(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!

    # Daily total MiB seconds of storage to ingest
    dailyMiBSeconds: Int!

    # MiB of data transfer to ingest
    transferredMiB: Int!

    # The number of advanced operations to ingest
    advancedOperationsCount: Int!

    # The number of basic operations to ingest
    basicOperationsCount: Int!
  ): CluiOutput

  # Migrate a users Reserved VM from cycles-based billing to usage-based billing. This is useful for testing and debugging and should NOT be used for real users
  migrateCyclesReservedVM(
    # The username or email of a single user
    target: String!

    # repl ID
    repl: String!
  ): CluiOutput

  # Suspend usage-based services for a user and optionally ban the user from using those services.
  suspendOrBan(
    # The username, email, or ID of a single user
    user: String!

    # Whether the user argument is a user ID. If false, the user argument is a username or email.
    isUserId: Boolean

    # Whether to ban the user from usage-based services indefinitely. If true, the user will not be able to use usage-based services until unbanned.
    banIndefinitely: Boolean

    # The reason for suspending usage-based services for the user. This will be included in the email notification sent to the user.
    reason: String!
  ): CluiOutput

  # Unban a user from usage-based services. Should be used when a user has been banned from usage-based services and the ban should be lifted after review and determining they are not intending to abuse usage-based services.
  unban(
    # The username, email, or ID of a single user
    user: String!

    # Whether the user argument is a user ID. If false, the user argument is a username or email.
    isUserId: Boolean

    # The reason for unbanning the user from usage-based services.
    reason: String!
  ): CluiOutput

  # Manually synchronize a user's Orb subscription according to their current Replit subscription.
  synchronizeSubscription(
    # The username, email, or ID of a single user
    user: String!

    # Whether the user argument is a user ID. If false, the user argument is a username or email.
    isUserId: Boolean
  ): CluiOutput

  # Grant customer credit for usage-based billing to a user. Please post in Slack #billing channel to get approval before using this command. Customer credit balances are applied to future invoices when the invoice is finalized.
  grantCustomerCredit(
    # The username or email of a single user
    user: String!

    # The amount of credit to grant in USD
    amountUsd: Float!

    # The reason for granting credit
    reason: String!
  ): CluiOutput
}

enum FakeDevComputeTier {
  dev_compute_0_5cpu_0_5ram
  dev_compute_1cpu_1ram
  dev_compute_4cpu_8ram
  dev_compute_8cpu_16ram
  dev_compute_16cpu_32ram
  dev_compute_32cpu_64ram
}

type AdminCluiUserStorageMutation {
  # Sync a user's storage quota with their database state. Useful if scheduled jobs fail and user's storage quota is in a bad state.
  sync(
    # User's username, email, or id
    user: String!
  ): CluiOutput
}

type AdminCliUserSmsVerificationMutation {
  # Clears a user's verified phone number. We don't allow users to do this themselves because it means that they could move a single phone number around between accounts.
  clear(
    # The username, phone number (+15555555555), or email of a single user
    target: String!
  ): CluiOutput

  # Forces phone number verification. This should only be used for staff accounts.
  verify(
    # The username or email of a single user
    target: String!

    # Optional, E.164 formatted phone number. If not provided, we pick a random +1-555-555-XXXX number.
    phoneNumber: String
  ): CluiOutput
}

type AdminCliUserFuidMutation {
  # Removes the database FUID value for a user.
  unset(
    # The username or email of a single user for which to remove the fuid
    target: String!
  ): CluiOutput
}

type AdminCliStripeMutation {
  # Changes a user's active Stripe subscription from one product to another.
  changeProduct(
    # The username or email of a single user
    user: String!

    # The new product ID. If the product is a downgrade, the user will receive a credit balance (not a refund). If the product is an upgrade, they will be charged immediately for the prorated difference in prices.
    newProductId: AdminCluiUserStripeProducts!
  ): CluiOutput

  # Create a new subscription for a user.
  newSubscription(
    # The username or email of a single user
    user: String!

    # The new product ID. If you don't see the product you expect in this list, please reach out to #billing.
    newProductId: AdminCluiUserStripeProducts!

    # The number of trial months to grant as part of the new subscription. The default is zero, which will cause the user to be invoiced immediately.
    trialMonths: Int = 0
  ): CluiOutput

  # Refund's a Stripe customer's credit balance.
  refundBalance(
    # The username or email of a single user
    user: String!
  ): CluiOutput
}

enum AdminCluiUserStripeProducts {
  # Replit Core at $20/month.
  replit_core_monthly

  # Replit Core at $120/year. This promotional price ends 2023-12-31, after which it will be $220/year.
  replit_core_yearly

  # Replit Core at $7/month. This should be used very rarely. If grandfathered Hacker users cancel their subscriptions, they are inellgible for the legacy pricing.
  legacy_hacker_monthly

  # Replit Core at $74/year. This should be used very rarely. If grandfathered Hacker users cancel their subscriptions, they are inellgible for the legacy pricing.
  legacy_hacker_yearly
}

type AdminCliRolesMutation {
  # Adds role to user
  add(
    # The role to add
    role: UserRoles!

    # User's username or email
    user: String!
  ): CluiOutput

  # Removes role from user
  remove(
    # The role
    role: UserRoles!

    # User's username or email
    user: String!
  ): CluiOutput
}

type AdminTeamMutation {
  # Moves team to destination org.
  moveTeamToOrg(
    # team name
    team: String!

    # org id
    orgId: Int!
  ): CluiOutput

  # Add or remove team member
  addRemoveTeamMember(
    # User's username or email
    user: String!

    # team name
    team: String!

    # Permission level. If the user is already a team member, it will change the permissions level to one selected.
    permissions: TeamPermission

    # Select if you want to remove this member from the team
    remove: Boolean
  ): CluiOutput

  # Remove a git repository repl from team
  removeGitRepositoryRepl(
    # team name
    team: String!

    # repl ID
    repl: String!
  ): CluiOutput

  # Add a git repository Repl to a team
  addGitRepositoryRepl(
    # team name
    team: String!

    # repl ID
    repl: String!
  ): CluiOutput
}

type AdminCliBannersMutation {
  # Adds a site-wide banner
  add(
    # The message to add
    message: String!
  ): CluiOutput

  # Removes the site-wide banner
  remove: CluiOutput
}

type AdminCliAppEnvMutation {
  # Append a value to an app-wide list variable
  append(
    # The key name
    key: String!

    # The value to append
    value: String!
  ): CluiOutput

  # Remove a value from an app-wide list variable
  remove(
    # The key name
    key: String!

    # The value to remove
    value: String!
  ): CluiOutput

  # Set an app-wide variable
  set(
    # The key name
    key: String!

    # The value
    value: String!
  ): CluiOutput

  # Unset an app-wide variable
  unset(
    # The key to unset
    key: String!
  ): CluiOutput
}

type AdminCliReplMutation {
  # Poison a Repl. Transfers the Repl and all forks (recursively) to the tarpit.
  poison(
    # repl ID
    repl: String!

    # Prevents users from forking this repl and any of its forks (recursive)
    disableForking: Boolean = false
  ): CluiOutput

  # Removes the poison status from the target Repl and all its forks recursively. This moves all those repls back to the appropriate cluster. For heavily forked repls (>20k), this job might time out. In that case you should run the script/cleasneReplTree script locally against production.
  cleanse(
    # repl ID
    repl: String!
  ): CluiOutput

  # Delete a Repl (will appear in the user's trash)
  delete(
    # repl ID
    repl: String!
  ): CluiOutput

  # Takedown a Repl (if the Repl is deleted but still running)
  takedown(
    # repl ID
    repl: String!
  ): CluiOutput

  # Transfer a Repl to a cluster
  clusterTransfer(
    # repl ID
    repl: String!

    # Destination cluster
    cluster: String!
  ): CluiOutput

  # Migrate a Repl to an Org
  migrateToOrg(
    # Organization ID
    orgId: String!

    # User ID to run migration as - will be assigned as "creator" of the Repl in the Org
    asUserId: Int!

    # Space-separated list of Repl IDs or URLs. Maximum of 50.
    repls: String!
  ): CluiOutput
}

type AdminCliTemplatesMutation {
  # Unpublish a template.
  unpublish(
    # The template repl id
    replId: String!
  ): CluiOutput

  # View and manage template categories
  categories: AdminCliTemplatesCategoriesMutation
}

type AdminCliTemplatesCategoriesMutation {
  # Add or edit a template category.
  addOrUpdate(
    # The title of the template category, e.g. Games
    title: String

    # The description of the template category, e.g. Learn how to build games.
    description: String

    # The image url to be displayed with the template category, e.g. /public/images/cat-1.jpg Note: currently all category images are hosted locally and need to be uploaded via PR.
    imageUrl: String

    # A number which will determine a categories position on the templates page, e.g 2
    order: Int

    # Select if you want to update an already existing template category
    update: Boolean

    # ID of the template category to update if applicable
    updateTemplateId: Int
  ): CluiOutput

  # Delete a template category.
  delete(
    # The id of the template category to be deleted.
    id: Int!
  ): CluiOutput
}

type AdminCurriculumHubMutation {
  # Export a team as curriculum
  exportCurriculum(
    # Source team username
    team: String!
  ): CluiOutput

  # Export a team as curriculum
  changeCurriculumStatus(
    # Curriculum version id
    versionId: Int!

    # Version status
    status: CurriculumVersionStatus!
  ): CluiOutput
}

enum CurriculumVersionStatus {
  draft
  in_review
  published
}

type AdminCliHostingDeploymentsMutation {
  # Delete a Hosting Deployment.
  delete(
    # The ID of the repl associated with your hosting deployment
    replId: String!
  ): CluiOutput

  # Suspend a Hosting Deployment.
  suspend(
    # The ID of the repl associated with your hosting deployment
    replId: String!
  ): CluiOutput

  # Resume a Hosting Deployment.
  resume(
    # The ID of the repl associated with your hosting deployment
    replId: String!
  ): CluiOutput
}

type AdminCliBillingOrgsMutation {
  # Add or remove an admin from the org.
  addRemoveAdmin(
    # The org id
    orgId: Int!

    # The user id to add or remove as an admin.
    userId: Int!

    # Select if you want to remove this user from the org
    remove: Boolean
  ): CluiOutput

  # Verify or reject teachers
  verifyTeacher(
    # User IDs (comma or space separated)
    userIds: String!

    # Verification action
    action: action!
  ): CluiOutput

  # Provision an test organization using the new orgs system, and creates a team subscription in Orb. For you to get an active subscription, you must go to the org settings and add a valid payment method.
  provisionTestOrg(
    # Username of the organization owner. This makes that user an Admin.
    adminUser: String!

    # Name of the Org to provision. Not required for personal orgs.
    name: String

    # Org type
    type: OrgType!

    # [team orgs only] Price per seat for the org. If not provided, the default price will be used.
    seatPrice: Float

    # [team orgs only] Number of seats to provision for the org. Required for team orgs.
    numSeats: Int
  ): CluiOutput

  # Provision an organization
  provision(
    # Username of the organization owner
    owner: String!

    # Organization name
    name: String!

    # Team name
    teamName: String

    # Plan prefix
    plan: CLUITeamOrganizationPlanPrefix!

    # Billing interval
    interval: CLUITeamOrganizationBillingInterval

    # When the trial period ends (yyyy-mm-dd)
    trialEnd: String

    # Seat count (only applies to per-seat plans)
    seatCount: Int!

    # When the subscription ends (yyyy-mm-dd); only applicable to custom deals
    timeExpired: String
  ): CluiOutput

  # Provision an edu organization. This is a temporary tool for the Teams Edu deprecation process, please do not use this outside of staff testing
  provisionEduOrg(
    # Username of the organization owner
    owner: String!

    # Organization name
    name: String!
  ): CluiOutput

  # Provision an Org a subscription in Orb. This is not saved in our DB until we get a successful payment of seats
  provisionOrbSubscription(
    # Username of the organization owner. This makes that user an Admin, and their email will be used for the orb and stripe customers
    adminUser: String!

    # ID of the org to provision
    orgId: String!

    # Number of seats to provision for the org.
    numSeats: Int!

    # Price per seat for the org. If not provided, the default price will be used.
    seatPrice: Float
  ): CluiOutput

  # Synchronizes an Orb subscription for an Org to our Database.
  syncOrgSubscriptionToDatabase(
    # The ID of the org to synchronize the subscription for.
    orgId: String!
  ): CluiOutput
}

enum action {
  verify
  reject
}

enum OrgType {
  personal
  team
}

enum CLUITeamOrganizationPlanPrefix {
  teams_pro
}

enum CLUITeamOrganizationBillingInterval {
  monthly
  annual
}

type AdminCliSubscriptionsMutation {
  # Override subscriptions (leave blank to view overrides)
  override(
    # username or email
    username: String

    # organization ID
    orgId: Int

    # Override expiration (format: yyyy-mm-dd)
    overrideExpiration: String

    # Ignore expiration? (infinite subscription)
    ignoreExpiration: OverrideBehaviorEnum

    # Override quantity (only for seat-based plans)
    overrideQuantity: Int

    # Ignore quantity? (infinite quantity)
    ignoreQuantity: OverrideBehaviorEnum

    # Why is this override being modified? (required if any override provided)
    reason: String
  ): CluiOutput
}

enum OverrideBehaviorEnum {
  enabled
  disabled
}

type ManualCurationMutation {
  # Make a Repl trend in the community
  add(
    # The Repl URL to add to the trending stack
    url: String!
  ): CluiOutput

  # remove a selected Repl from the curated homepage picks
  remove(
    # The Repl URL to remove from the trending list
    url: String!
  ): CluiOutput

  # reset the redis cache for trending items manually (add & remove do this automatically)
  refresh: CluiOutput
}

type AdminCliExtensionMutation {
  # This deletes an extension by its id. Remember to inform the extension creator why we are deleting their extension, and post in the #ws_extensions channel
  delete(
    # The extension's ID
    extensionId: String!
  ): CluiOutput

  # This updates an extension by its id. Remember to inform the extension creator what we are changing, and post in the #ws_extensions channel
  update(
    # The extension's ID
    extensionId: String!

    # The extension's new name
    name: String

    # The extension's new description
    description: String

    # The extension's new url
    url: String

    # The extension's new slug
    slug: String

    # Whether or not the extension is blessed. (true / false / [leave blank])
    isBlessed: String

    # Whether or not the extension is publicly listed on the store. (true / false / [leave blank])
    isListed: String

    # Whether or not the extension is featured on the store. (true / false / [leave blank])
    isFeatured: String

    # Whether or not the extension is disabled from loading (true / false / [leave blank])
    isDisabled: String
  ): CluiOutput

  # This transfers an extension to a new user
  transfer(
    # The extension's ID
    extensionId: String!

    # The new user's ID
    newUserId: Int!
  ): CluiOutput

  # This restores an extension by its id
  restore(
    # The extension's ID
    extensionId: String!
  ): CluiOutput

  # This deploys an extension by its id
  deploy(
    # The extension's ID
    extensionId: String!
  ): CluiOutput
}

type AdminEduExportMutation {
  # Export a team edu as an admin - this will bypass team membership and let you export any team for testing purposes
  exportTeamsTeacher(
    # Username of team to export
    teamName: String!
  ): CluiOutput

  # Export a team edu as a student - this will bypass team and student membership
  exportTeamsStudent(
    # Username of team to export
    teamName: String!

    # Username of student who is exporting
    userName: String!
  ): CluiOutput

  # DANGER - Delete an export run by id from the edu_team_exports table - only use if data is compromised!
  deleteExportRun(
    # ID of export run to delete
    id: Int!
  ): CluiOutput

  # View export history runs for an edu team as an admin.
  viewExportRuns(
    # Username of team to view runs
    teamName: String!
  ): CluiOutput
}

type AdminCliCloudServicesMutation {
  # View, Delete.
  neonDatabase: AdminCliNeonDatabaseMutation
}

type AdminCliNeonDatabaseMutation {
  # Delete a Neon database.
  delete(
    # The ID of the repl associated with the Neon database
    replId: String!
  ): CluiOutput
}

type AdminCliNotificationsMutation {
  # Send push to a staff user
  sendPushToStaffUser(
    # User's username or email
    user: String!

    # title
    messageTitle: String!

    # message
    messageBody: String!

    # url
    url: String
  ): CluiOutput
}

type StaffCluiMutation {
  # Configure tours
  tours: StaffCliToursMutation
}

type StaffCliToursMutation {
  # Updates whether a tour has been seen for a user.
  updateTourSeen(
    # User's username or email
    user: String!

    # The name of the tour to update
    tourName: String!

    # Whether or not the tour should be marked as seen
    shouldBeMarkedAsSeen: Boolean
  ): CluiOutput

  # Clears all the tours that a user has seen.
  clearUserTours(
    # User's username or email
    user: String!
  ): CluiOutput
}

type UserCliAccountMutation {
  # Change your username (this can only be done once)
  changeUsername(username: String!): CluiOutput

  # Exchange Cycles for usage credits which will be applied to your future usage invoices. This is an irreversible operation.
  cyclesToUsageCredits(
    # Number of cycles to exchange
    cycles: Int!
  ): CluiOutput
}

type ModeratorCluiMutation {
  # Unpublish a repl
  unpublish(
    # The repl's url
    replUrl: String!

    # Reason for unpublishing (10 words or less)
    reason: String!
  ): CluiOutput

  # Remove a tag on Apps
  removeTag(
    # The tag (do not include the #)
    tag: String!

    # Reason for removing tag (5 words or less)
    reason: String!

    # This will ban the tag from future use and send a Warn to any user that has used this tag.
    banTag: Boolean!
  ): CluiOutput

  # Ban, warn, view-warns, etc.
  user: ModeratorCliUserMutation
}

type ModeratorCliUserMutation {
  # Ban a user from Repl Talk.
  ban(
    # User's username or email
    user: String!

    # Reason for ban
    reason: String
  ): CluiOutput

  # Warn a user.
  warn(
    # User's username or email
    user: String!

    # Reason for warn
    reason: String!
  ): CluiOutput

  # Remove a warning by its id.
  removeWarn(
    # User's username or email
    user: String!

    # Id of warning to remove
    warnId: Int!
  ): CluiOutput
}

type TrashMutation {
  # Restore a deleted Repl by its title
  restoreRepl(
    # title of Repl that will be restored
    title: String!
  ): CluiOutput

  # Restore a deleted Repl folder by its name
  restoreFolder(
    # name of Repl folder that will be restored
    name: String!

    # restore Repls in folder
    andRepls: Boolean
  ): CluiOutput
}

type TeamMutation {
  # transfer one of your Repls to a team
  transferRepl(
    # The Repl slug or url
    repl: String!

    # team name
    team: String!

    # Replit Deployments aren't supported for teams yet and will be deleted on transfer.
    confirm: Boolean! = false
  ): CluiOutput

  # Forks an existing Repl to create a team project
  forkReplToProject(
    # The Repl url
    replUrl: String!

    # If "checked" it will create a group project (you can not change this later)
    isGroupProject: Boolean = false

    # team name
    team: String!
  ): CluiOutput

  # restore one of your deleted projects in a team
  restoreProject(
    # The title of project that will be restored
    project: String!

    # team name
    team: String!

    # If checked, will restore student submissions for this project
    submissions: Boolean
  ): CluiOutput

  # restore one of your deleted repls in a team (WARNING: use restoreEduProject command for Teams for Education projects, not this command!)
  restoreRepl(
    # The title of repl that will be restored
    title: String!

    # team name
    team: String!
  ): CluiOutput

  # Update an existing team invite link
  updateInvite(
    # The invite link
    inviteLink: String!

    # Whether the link is a privacy link (read more here: https://docs.replit.com/teams-edu/inviting-teachers-students#invite-students-in-privacy-mode)
    isPrivacyLink: Boolean
  ): CluiOutput
}

type ExtensionMutation {
  # Create a new extension
  create(
    # The extension's URL
    url: String!

    # The extension's name
    name: String!

    # The extension's description
    description: String!
  ): CluiOutput

  # Update an extension
  update(
    # The extension's ID
    extensionId: String!

    # The extension's new name
    name: String

    # The extension's new description
    description: String

    # The extension's new url
    url: String

    # The extension's new slug
    slug: String
  ): CluiOutput

  # Delete an extension
  delete(
    # The extension's ID
    extensionId: String!
  ): CluiOutput
}

union LinkReplDomain2 =
    UnauthorizedError
  | ServiceUnavailable
  | NotFoundError
  | Repl

union CreateAnnotationAnchorOutput = UserError | AnnotationAnchor

input AnnotationAnchorInput {
  id: String!
  replId: String!
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  isResolved: Boolean
  isGeneral: Boolean
}

input AnnotationMessageInput {
  id: String!
  text: String!
  mentions: [String!]
  anchorId: String
}

input AnnotationHighlightInput {
  precode: String
  code: String
  postcode: String
}

union CreateAnnotationMessageOutput = UserError | AnnotationAnchor

union UpdateAnnotationAnchorOutput = UserError | AnnotationAnchor

input AnnotationAnchorChangesInput {
  path: String
  otVersion: Int
  indexStart: Int
  indexEnd: Int
  isResolved: Boolean
}

input DeleteTeamInput {
  teamId: Int!
  cancelationReason: String
}

input UpdateTeamInput {
  id: Int!
  username: String
  description: String
  displayName: String
  profileImage: String
}

union RemoveTeamMemberOutput = UserError | Team

input RemoveTeamMemberInput {
  teamId: Int!
  memberId: Int!
}

union LeaveTeamOutput = UserError | Team

union CreateTeamInviteOutput = UserError | TooManyRequestsError | Team

input CreateTeamInviteInput {
  teamId: Int!
  usernameOrEmail: String!
}

union DeleteTeamInviteOutput = UserError | Team

input DeleteTeamInviteInput {
  teamId: Int!
  usernameOrEmail: String
  inviteId: Int
}

union CreateTeamInviteLinkOutput = UserError | Team

union DeleteTeamInviteLinkOutput = UserError | Team

union UpdateTeamUserPermissionsOutput = UserError | Team

input UpdateTeamUserPermissionsInput {
  # The ID of the team
  id: Int!

  # The user whose permissions should be changed.
  user: Int!

  # The permissions the user should get
  permissions: TeamPermission!
}

union CreateReplTemplateOutput = UserError | ReplTemplate

input CreateReplTemplateInput {
  replId: String!
  imageUrl: String
  isPublished: Boolean
  dueDate: String
}

union CreateReplAsTemplateOutput = UserError | ReplTemplate

input CreateReplAsTemplateInput {
  title: String!
  originId: String
  replReleaseId: String
  description: String
  teamId: Int!
  imageUrl: String
  isPublished: Boolean
  isGroupProject: Boolean
  dueDate: String
  availableStartDate: String
  availableEndDate: String
  restrictAfterSubmit: Boolean
  allowSelfGrouping: Boolean
  selfGroupSize: Int
  stackId: Int
}

union UpdateReplTemplateOutputType = UserError | ReplTemplate

input UpdateReplTemplateInput {
  id: Int!
  imageUrl: String
  isPublished: Boolean
  submissionGroups: [SubmissionGroupInput]
  dueDate: String
  availableStartDate: String
  availableEndDate: String
  allowSelfGrouping: Boolean
  selfGroupSize: Int
}

input SubmissionGroupInput {
  submissionId: Int
  userIds: [Int]!
}

union SubmitReplOutput = Repl | UserError

union UnsubmitReplOutput = Repl | UserError

union ReviewReplOutput = Repl | UserError

union CreateReplSubmissionOutput = UserError | Repl

union TemplateTestOutput = ReplTemplateTest | UserError

input CreateTemplateTestInput {
  name: String!
  input: String!
  output: String!
  type: ReplTemplateTestType!
  templateId: Int!
}

union ReplUnitTestOutput = ReplUnitTest | UserError

input CreateReplUnitTestInput {
  name: String!
  code: String!
  failureMessage: String
  replId: String!
}

input UpdateReplUnitTestInput {
  name: String
  code: String
  failureMessage: String
  testId: Int!
}

union ReplUnitTestMetaOutput = ReplUnitTestMeta | UserError

input CreateReplUnitTestMetaInput {
  imports: String
  initialization: String
  setup: String
  tearDown: String
  replId: String!
}

input UpdateReplUnitTestMetaInput {
  imports: String
  initialization: String
  setup: String
  tearDown: String
  replId: String!
}

union UpdateReplUnitTestLastRunOutput =
    UpdateReplUnitTestLastRunUpdatedTests
  | UserError

type UpdateReplUnitTestLastRunUpdatedTests {
  updatedTests: [ReplUnitTestOutput!]!
}

input UpdateReplUnitTestLastRunInput {
  replId: String!
  results: [UpdateReplUnitTestLastRunInputResults!]!
}

input UpdateReplUnitTestLastRunInputResults {
  testId: Int!
  didPass: Boolean!
}

union DeleteReplTemplateOutput = ReplTemplate | UserError

input UpdateTemplateTestInput {
  name: String
  input: String
  output: String
  type: ReplTemplateTestType
  testId: Int!
}

input UpdateEditorPreferencesInput {
  isLayoutStacked: Boolean
  theme: String
  fontSize: Int
  mobileFontSize: Int
  acceptSuggestionOnCommitCharacter: Boolean
  indentIsSpaces: Boolean
  indentSize: Int
  indentDetection: Boolean
  indentFormatPastes: Boolean
  keyboardHandler: String
  wrapping: Boolean
  mobileWrapping: Boolean
  codeIntelligence: Boolean
  semanticTokens: Boolean
  codeSuggestion: Boolean
  completeCodeEngine: String
  chatAudioNotification: Boolean
  chatEngine: String
  ghostwriterUseAdvancedModel: Boolean
  ghostwriterChatServiceEnvironment: String
  accessibleTerminal: Boolean
  multiselectModifierKey: String
  webviewAutoOpenOnPortOpened: Boolean
  formatOnSave: Boolean
  codeActionsOnSave: Boolean
  forwardPortsAutomatically: String
  extraDelight: Boolean
  minimapDisplay: String
  rulers: [Int]
  shellBellAudio: Boolean
  showLeadingWhitespace: Boolean
  showEnclosedWhitespace: Boolean
  showTrailingWhitespace: Boolean
  showSelectedWhitespace: Boolean
  showFileTreeGitStatus: Boolean
  outputUpdateTrigger: String
}

input CSVFileInput {
  teamId: Int!
  content: String!
}

union ResetPrivacyStudentPasswordOutput =
    ResetPrivacyStudentPasswordSuccess
  | UserError

type ResetPrivacyStudentPasswordSuccess {
  success: Boolean!
}

union DeletedProjectAndSubmissionOutput = Team | UserError

union CreateReplReleaseOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input CreateReplReleaseInput {
  replId: String!
  description: String!
  initialLayoutState: JSON
}

union RevertReplReleaseOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input RevertReplReleaseInput {
  replId: String!
  releaseId: String!
}

union CreateReplDeployemntOutput =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Repl

input CreateReplDeployemntInput {
  replId: String!
  iconUrl: String!
  description: String!
}

union DeleteReplDeploymentOutput = UserError | NotFoundError | Repl

input DeleteReplDeploymentInput {
  replId: String!
}

union MarkMessagesAsSeenOutput = UserError | AnnotationMessageList

type AnnotationMessageList {
  messages: [AnnotationMessage!]!
}

union UpdateTeamOrganizationOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input UpdateTeamOrganizationInput {
  id: Int!
  name: String!
  isAiEnabled: Boolean
}

union SaveIOTestResultOutput = NotFoundError | UserError

# An input type for telling the server the results of an IO test.
input IOTestResultInput {
  # The output of the program when the test was executed.
  output: String!

  # The status of the test that was executed.
  status: IOTestResultStatus!

  # The ID of the test which was executed on the repl.
  testId: Int!
}

union UpdateTeamMemberOutput = UnauthorizedError | UserError | Team

input UpdateTeamMemberInput {
  # The ID of the team
  teamId: Int!

  # The user whose nickname should be changed.
  userId: Int!

  # Admin assigned nickname for member.
  nickname: String
}

union CreateTeamV2Output = UserError | UnauthorizedError | Team

input CreateTeamV2Input {
  username: String!
  orgId: Int
  displayName: String
  privacyInvite: Boolean
}

union ConnectGoogleClassroomOutput = UserError | NotFoundError | GoogleClassroom

input ConnectGoogleClassroomInput {
  teamId: Int!
  courseId: String!
  courseName: String!
  students: [ConnectGoogleClassroomStudentInput]!
}

input ConnectGoogleClassroomStudentInput {
  # Google profile ID of user
  id: String!

  # Google profile email of user
  email: String!
}

union DeleteMultiplayerInviteLink = UserError | Repl

union ExportTeamSubmissionsOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ExportTeamSubmissionsResult

type ExportTeamSubmissionsResult {
  folderPath: String!
}

union DisconnectGoogleClassroomOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Team

input DisconnectGoogleClassroomInput {
  teamId: Int!
}

union CreateReplSubmissionGroupOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | ServiceUnavailable
  | ReplSubmission

input CreateReplSubmissionGroupInput {
  teamId: Int!
  templateId: Int!
}

union JoinReplSubmissionGroupOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | ReplSubmission

input JoinReplSubmissionGroupInput {
  teamId: Int!
  submissionId: Int!
}

union ExportProjectsOverviewOutput =
    NotFoundError
  | UnauthorizedError
  | CurrentUser

input ExportProjectsOverviewInput {
  teamName: String!
  templateIds: [Int!]
}

union ArchviveTeamInput = UserError | NotFoundError | UnauthorizedError | Team

input ArchiveTeamInput {
  teamId: Int!
}

union UnarchiveTeamOutput = UserError | NotFoundError | UnauthorizedError | Team

input UnarchiveTeamInput {
  teamId: Int!
}

union SetLanguageTemplateOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Repl

input SetLanguageTemplateInput {
  language: String!
  replId: String
  betaReplId: String
}

union CreateStackOutput = Team | User | UserError | UnauthorizedError

input CreateStackInput {
  # Owner of the stack
  userId: Int!

  # Title of the stack
  title: String!

  # Description of the stack
  description: String
}

union ArrangeStackItemOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input ArrangeStackItemInput {
  # Repl in the stack.
  replId: String!

  # Stack the Repl belongs to. Set to 0 to ungroup the Repl from its existing stack.
  stackId: Int!

  # Stack the Repl previously belonged to.
  previousStackId: Int

  # Desired order in the stack.
  order: Int!
}

union ImportCurriculumOutput = NotFoundError | UnauthorizedError | Team

input ImportCurriculumInput {
  curriculumId: Int!
  versionNumber: Int!
  teamId: Int!
}

union UpdateStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input UpdateStackInput {
  # Id of the stack
  stackId: Int!

  # Title of the stack
  title: String

  # Description of the stack
  description: String
}

union DeleteStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

union ArrangeStackOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input ArrangeStackInput {
  stackId: Int!

  # Desired order with in the user profile
  order: Int!
}

union CreateReplPost2Output =
    UnauthorizedError
  | UserError
  | NotFoundError
  | Post

input CreateReplPost2Input {
  replId: String!
  tags: [String!]
  iconUrl: String
  body: String
  title: String
}

union UnpublishReplFromCommunityOutput =
    NotFoundError
  | UnauthorizedError
  | Repl

input UnpublishReplFromCommunityInput {
  replId: String!
}

union CodexFeedback2Output = UnauthorizedError | NotFoundError | CodexFeedback2

type CodexFeedback2 {
  id: String!
  feedback: CodexFeedbackEnum!
}

enum CodexFeedbackEnum {
  yes
  no
}

input CodexFeedback2Input {
  inferenceId: String!
  feedback: CodexFeedbackEnum!
  inferenceClass: CodexFeedback2CodexInferenceClassEnum!
}

enum CodexFeedback2CodexInferenceClassEnum {
  chat
}

union ToggleReplLikeOutput = UserError | NotFoundError | Repl

input ToggleReplLikeInput {
  replId: String!
}

union setFollowing =
    UserError
  | UnauthorizedError
  | NotFoundError
  | FollowResult

type FollowResult {
  user: User
  targetUser: User
}

input setFollowingInput {
  targetUserId: Int!
  shouldFollow: Boolean!
}

union SetBlocking2 = UnauthorizedError | NotFoundError | SetBlocking2Result

type SetBlocking2Result {
  isBlocked: Boolean!
  targetUser: User!
  currentUser: CurrentUser!
}

input SetBlocking2Input {
  targetUserId: Int!
  shouldBlock: Boolean!
}

union SetTemplateCategoryOutput = NotFoundError | Repl

input SetTemplateReplCategoryInput {
  replId: String!
  category: String!
}

union SetOnboardingTraitsOutput = UnauthorizedError | UserError | CurrentUser

enum OnboardingExperience {
  ONBOARDING_EXPERIENCE_NONE
  ONBOARDING_EXPERIENCE_LOW
  ONBOARDING_EXPERIENCE_MEDIUM
  ONBOARDING_EXPERIENCE_HIGH
}

enum Intent {
  INTENT_PERSONAL
  INTENT_STUDENT
  INTENT_TEACHER
  INTENT_BUSINESS
}

union CreateReplTemplateModelSolutionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input CreateReplTemplateModelSolutionInput {
  teamId: Int!
  templateId: Int!
  visibleAfterSubmitting: Boolean
  visibleAfterDueDate: Boolean
  visibleAfterPassingTests: Boolean
}

union CreateReplTemplateModelSolutionForkOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input CreateReplTemplateModelSolutionForkInput {
  teamId: Int!
  solutionId: Int!
}

union UpdateReplTemplateModelSolutionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input UpdateReplTemplateModelSolutionInput {
  teamId: Int!
  solutionId: Int!
  visibleAfterSubmitting: Boolean
  visibleAfterDueDate: Boolean
  visibleAfterPassingTests: Boolean
}

union UpdateTeamOrganizationMemberOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input UpdateTeamOrganizationMemberInput {
  orgId: Int!
  memberId: Int!
  role: TeamMemberRoleEnumType!
}

# Team organization member roles
enum TeamMemberRoleEnumType {
  OWNER
  ADMIN
}

union DeleteTeamOrganizationMemberOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrganizationMemberInput {
  orgId: Int!
  memberId: Int!
  retainTeamAccess: Boolean
}

union DeleteTeamOrganizationOutput =
    UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrganizationInput {
  orgId: Int!
}

union CreateTeamOrgInviteOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | TeamOrganization

input CreateTeamOrgInviteInput {
  orgId: Int!
  usernameOrEmail: String!
}

union DeleteTeamOrgInviteOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TeamOrganization

input DeleteTeamOrgInviteInput {
  orgId: Int!
  inviteId: Int!
}

union UpdateSubscription =
    UserError
  | NotFoundError
  | UnauthorizedError
  | UpdateSubscriptionOutput

type UpdateSubscriptionOutput {
  subscriptions: [Subscription!]!
}

type Subscription {
  id: Int!
  quantity: Int!
  isTrial: Boolean!
  timeActivated: Date!
  timeExpired: Date!
  timeCreated: Date!
  timeUpdated: Date!
  timeDeleted: Date
  product: Product!
  status: String
}

type Product {
  id: Int!
  planPrefix: String!
  description: String
}

input UpdateSubscriptionInput {
  orgId: Int!
  product: UpdateSubscriptionLineItemInput!
}

input UpdateSubscriptionLineItemInput {
  # Product ID (only if changing subscribed product)
  id: Int

  # Subscription quantity (only if changing quantity)
  quantity: Int
}

union CreateTeamOrgInviteLinkOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | TooManyRequestsError
  | TeamOrganization

union DeleteTeamOrgInviteLinkOutput =
    NotFoundError
  | UnauthorizedError
  | TeamOrganization

union CopyTeamTemplateOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input CopyTeamTemplateInput {
  # Team project to copy
  templateId: Int!

  # Destination team
  destinationTeamId: Int!

  # Destination stack in team (optional)
  destinationStackId: Int
}

union CopyStacksToTeamOutput =
    Team
  | User
  | UserError
  | UnauthorizedError
  | NotFoundError

input CopyStacksToTeamInput {
  # Stacks and Template IDs selected for copying
  stacks: [stacks!]!

  # Destination team to copy to
  destinationTeamId: Int!

  # Source team to copy from
  sourceTeamId: Int!
}

input stacks {
  # ID of stack selected for copying
  id: Int!

  # List IDs of templates which have been selected for copying
  templateIds: [Int!]!
}

union JoinTeamAsOrgAdminOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Team

union SetUserSocialsOutput = UserError | UnauthorizedError | CurrentUser

input SetUserSocialsInput {
  socials: [SetUserSocialInput!]!
}

input SetUserSocialInput {
  url: String
  type: UserSocialEnum!
}

enum UserSocialEnum {
  twitter
  facebook
  linkedin
  github
  discord
  youtube
  twitch
  website
}

union UpdateUserSitePresenceOutput =
    ServiceUnavailable
  | UnauthorizedError
  | CurrentUser

union UpdateUserPrivacyPreferencesOutput =
    UnauthorizedError
  | UserError
  | CurrentUser

input UpdateUserPrivacyPreferencesInput {
  show_presence: UserPrivacyPreferenceShowPresenceOptions
}

enum UserPrivacyPreferenceShowPresenceOptions {
  never
  when_online
  where_online
}

union SetUserCoverImageOutput = UserError | UnauthorizedError | CurrentUser

input SetUserCoverImageInput {
  # Image ID to set as the cover image
  imageId: Int

  # Y position offset for adjusting image viewport area
  offsetY: Int

  # Remove the cover image
  remove: Boolean
}

union CreateThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input CreateThemeInput {
  title: String!
  description: String!
  colorScheme: CustomThemeColorScheme!
}

union UpdateThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UpdateThemeInput {
  themeId: Int!
  description: String!
  values: UpdateThemeInputThemeValues!
}

input UpdateThemeInputThemeValues {
  global: UpdateThemeInputThemeValuesGlobal!
  editor: UpdateThemeInputThemeValuesEditor!
}

# The global Theme values
input UpdateThemeInputThemeValuesGlobal {
  backgroundRoot: String!
  backgroundDefault: String!
  backgroundHigher: String!
  backgroundHighest: String!
  backgroundOverlay: String!
  foregroundDefault: String!
  foregroundDimmer: String!
  foregroundDimmest: String!
  outlineDimmest: String!
  outlineDimmer: String!
  outlineDefault: String!
  outlineStronger: String!
  outlineStrongest: String!
  accentPrimaryDimmest: String!
  accentPrimaryDimmer: String!
  accentPrimaryDefault: String!
  accentPrimaryStronger: String!
  accentPrimaryStrongest: String!
  accentPositiveDimmest: String!
  accentPositiveDimmer: String!
  accentPositiveDefault: String!
  accentPositiveStronger: String!
  accentPositiveStrongest: String!
  accentNegativeDimmest: String!
  accentNegativeDimmer: String!
  accentNegativeDefault: String!
  accentNegativeStronger: String!
  accentNegativeStrongest: String!
  redDimmest: String!
  redDimmer: String!
  redDefault: String!
  redStronger: String!
  redStrongest: String!
  orangeDimmest: String!
  orangeDimmer: String!
  orangeDefault: String!
  orangeStronger: String!
  orangeStrongest: String!
  yellowDimmest: String!
  yellowDimmer: String!
  yellowDefault: String!
  yellowStronger: String!
  yellowStrongest: String!
  limeDimmest: String!
  limeDimmer: String!
  limeDefault: String!
  limeStronger: String!
  limeStrongest: String!
  greenDimmest: String!
  greenDimmer: String!
  greenDefault: String!
  greenStronger: String!
  greenStrongest: String!
  tealDimmest: String!
  tealDimmer: String!
  tealDefault: String!
  tealStronger: String!
  tealStrongest: String!
  blueDimmest: String!
  blueDimmer: String!
  blueDefault: String!
  blueStronger: String!
  blueStrongest: String!
  blurpleDimmest: String!
  blurpleDimmer: String!
  blurpleDefault: String!
  blurpleStronger: String!
  blurpleStrongest: String!
  purpleDimmest: String!
  purpleDimmer: String!
  purpleDefault: String!
  purpleStronger: String!
  purpleStrongest: String!
  magentaDimmest: String!
  magentaDimmer: String!
  magentaDefault: String!
  magentaStronger: String!
  magentaStrongest: String!
  pinkDimmest: String!
  pinkDimmer: String!
  pinkDefault: String!
  pinkStronger: String!
  pinkStrongest: String!
  greyDimmest: String!
  greyDimmer: String!
  greyDefault: String!
  greyStronger: String!
  greyStrongest: String!
  brownDimmest: String!
  brownDimmer: String!
  brownDefault: String!
  brownStronger: String!
  brownStrongest: String!
  black: String!
  white: String!
}

# The editor Theme values
input UpdateThemeInputThemeValuesEditor {
  syntaxHighlighting: [UpdateThemeInputEditorSyntaxHighlighting!]!
}

# An object which contains CSS styles that are applied to a given set of editor tags
input UpdateThemeInputEditorSyntaxHighlighting {
  tags: [UpdateThemeInputEditorTag]!
  values: JSON!
}

# A selector for a given editor tag
input UpdateThemeInputEditorTag {
  name: String!
  modifiers: [String!]
}

union PublishThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input PublishThemeInput {
  themeId: Int!

  # Description for the version of the theme to be published
  description: String
}

union UnpublishThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UnpublishThemeInput {
  themeId: Int!
}

union UnpublishThemeAsModeratorOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UnpublishThemeAsModeratorInput {
  themeId: Int!
  reason: String!
}

union InstallThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input InstallThemeInput {
  themeId: Int!
}

union UninstallThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UninstallThemeInput {
  themeId: Int!
}

union DeleteThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input DeleteThemeInput {
  themeId: Int!
}

union UpgradeThemeOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CustomTheme

input UpgradeThemeInput {
  themeId: Int!
}

union SetActiveThemeOutput = UserError | NotFoundError | CustomTheme

# Input for the setActiveTheme mutation. Passing in a null themeId indicates that the custom theme the user has active is cleared in favor of an official theme. Passing in a non-null officialThemeKey sets the official theme to the Replit theme with that key (ignored if themeId is non-null)
input SetActiveThemeInput {
  themeId: Int
  officialThemeKey: OfficialReplitThemeKey
}

enum OfficialReplitThemeKey {
  replitLight
  replitDark
  replitSpooky
}

union ReportCustomThemeOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BoardReport

union ToggleHiddenPostOutput = NotFoundError | UserError | Post

union ImportGithubRepoOutput =
    NotFoundError
  | UserError
  | UnauthorizedError
  | ServiceUnavailable
  | Repl

input ImportGithubRepoInput {
  githubRepoUrl: String!
  teamId: Int
  orgId: String
  folderId: String
  isPrivate: Boolean
  forkToPersonal: Boolean

  # The active release ID of the Repl template to import this repository into.
  activeReplReleaseId: String

  # The active origin ID of the Repl template to import this repository into. If null the template origin id will be determined automatically.
  originId: String
}

input GraphQLGitHubApiFile {
  path: String!
  type: GraphQLGitHubApiFileType!
}

enum GraphQLGitHubApiFileType {
  file
  dir
}

union WarnUserOutput = UserError | Warning

union RemoveWarnOutput = UserError | Warning

union BanCommunityUserOutput = UserError | BannedBoardUser

union SetReplLayoutStateOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input SetReplLayoutStateInput {
  replId: String!
  state: JSON!

  # Environment to save the layout state for
  environment: LayoutStateEnvironmentEnum
}

union SetReplTagsOutput = UnauthorizedError | UserError | NotFoundError | Repl

input SetReplTagsInput {
  replId: String!
  tags: [String!]!
}

union SetReplViewSettingsOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ReplViewSettings

input SetReplViewSettingsInput {
  replId: String!
  defaultView: ReplViewSettingsDefaultView

  # The file used, if the defaultView is repl_file
  replFile: String

  # The image used, if the defaultView is repl_image
  replImage: String
}

enum ReplViewSettingsDefaultView {
  repl_file
  repl_image
}

union CreateTeacherVerificationResponseOutput =
    UserError
  | UnauthorizedError
  | TeacherVerification

input CreateTeacherVerificationResponseInput {
  orgNames: String!
  website: String!
  useCase: String!
  howManyLearners: String!
  referringEmailOrName: String
}

union EscalateBoardUserOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | BoardReport

union ReviewTemplateOutput = UserError | UnauthorizedError | TemplateReview

input ReviewTemplateInput {
  # Template Repl to promote or demote
  replId: String!

  # True to promote, false to demote
  shouldPromote: Boolean!
}

union UpdatePrivatePowerUpOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UserPowerUpDescriptionType

union UpdatePrivatePowerUp2Output =
    UserError
  | UnauthorizedError
  | NotFoundError
  | CurrentUser

union UnbanCommunityUserOutput = UserError | User

input UnbanCommunityUserInput {
  username: String!
}

union ModeratorUnpublishOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | Repl

input ModeratorUnpublishInput {
  replId: String!
  reason: String!
}

union CreateUserCourseOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseResult

type UserCourseResult {
  userCourse: UserCourse!
}

input CreateUserCourseInput {
  # The course to start.
  courseSlug: String!
}

union CreateUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseLessonResult

type UserCourseLessonResult {
  userCourseLesson: UserCourseLesson!
}

input CreateUserCourseLessonInput {
  # The UserCourse associated with the lesson. This id is an integer.
  userCourseId: Int!

  # The lesson being created.
  lessonSlug: String!

  # The locale for which we want to create the lesson. If not provided, defaults to "en-US".
  locale: String = "en-US"

  # Deprecated. The server handles Repl forking now.
  replId: String
}

union UpdateUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UpdatedUserCourseLesson

type UpdatedUserCourseLesson {
  userCourseLesson: UserCourseLesson!
}

input CompleteUserCourseLessonInput {
  # The numeric ID for the UserCourseLesson to update.
  userLessonId: Int!
}

union RestartUserCourseLessonOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | UserCourseLessonResult

input RestartUserCourseLessonInput {
  # The ID for the lesson to be restarted.
  userLessonId: Int!

  # The locale for which we want the user to restart their lesson. If not provided, defaults to "en-US"
  locale: String = "en-US"
}

union SetTemplateCategoryReplOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | TemplateCategoryReplResult

type TemplateCategoryReplResult {
  templateCategoryRepl: TemplateCategoryRepls!
}

# Assign a template category to a template repl.
type TemplateCategoryRepls {
  id: Int!
  replId: String!
  templateCategoryId: Int!
  timeCreated: Date!
}

input SetTemplateCategoryReplInput {
  # The associated repl id.
  replId: String!

  # The target template category id.
  templateCategoryId: Int!
}

union UnsetTemplateCategoryReplOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | TemplateCategoryReplResult

input UnsetTemplateCategoryReplInput {
  # The associated repl id.
  replId: String!

  # The target template category id.
  templateCategoryId: Int!
}

union ModeratorNotificationOutput =
    MentionedInPostNotification
  | MentionedInCommentNotification
  | RepliedToCommentNotification
  | RepliedToPostNotification
  | AnswerAcceptedNotification
  | MultiplayerJoinedEmailNotification
  | MultiplayerJoinedLinkNotification
  | MultiplayerInvitedNotification
  | MultiplayerOverlimitNotification
  | WarningNotification
  | TeamInviteNotification
  | TeamOrganizationInviteNotification
  | BasicNotification
  | TeamTemplateSubmittedNotification
  | TeamTemplateReviewedStatusNotification
  | AnnotationNotification
  | ReplCommentCreatedNotification
  | ReplCommentReplyCreatedNotification
  | ReplCommentMentionNotification
  | ThreadNotification
  | NewFollowerNotification
  | BountyApplicationReviewedNotification
  | BountyNewApplicationNotification
  | BountyNewSubmissionNotification
  | BountySubmissionReviewedNotification
  | BountyChatMessageNotification
  | EgressLimitNotification
  | NotFoundError
  | UnauthorizedError

input ModeratorNotificationInput {
  username: String!
  text: String!
  url: String!
}

union CreateBountyOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | Bounty

input CreateBountyInput {
  title: String!
  description: String!
  cycles: Int!
  deadline: DateTime!
  contactMethod: BountyContactMethod!
  contactInfo: String!
  isUnlisted: Boolean
}

union EditBountyOutput = UserError | UnauthorizedError | NotFoundError | Bounty

input EditBountyInput {
  bountyId: Int!
  title: String
  description: String
  cycles: Int
  deadline: DateTime
  contactInfo: String
}

union CancelBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input CancelBountyInput {
  id: Int!
}

union CreateBountyApplicationOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | BountyApplication

input CreateBountyApplicationInput {
  bountyId: Int!
  content: String!
  contactInfo: String!
  hcaptchaResponse: String
  hcaptchaSiteKey: String
}

union CreateBountySubmissionOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountySubmission

input CreateBountySubmissionInput {
  bountyId: Int!

  # The text content of the submission
  content: String!

  # Repls that should be part of this submission and shared with the Bounty poster
  replIds: [String!]
}

union CreateBountySubmissionReviewOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountySubmissionReview

input CreateBountySubmissionReviewInput {
  bountySubmissionId: Int!
  isAccepted: Boolean!
  content: String
}

union ReviewBountyApplicationOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyApplication

input ReviewBountyApplicationInput {
  bountyApplicationId: Int!
  status: ReviewBountyApplicationStatus!
}

enum ReviewBountyApplicationStatus {
  accepted
  rejected
  notReviewed
}

union ModerateBountyApplicationOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | BountyApplication

input ModerateBountyApplicationInput {
  bountyApplicationId: Int!
  action: ModerateBountyApplicationAction!
  reason: String
  notifyApplicant: Boolean
}

enum ModerateBountyApplicationAction {
  delete
  approve
}

union SetBountyUnlistedOutput = UserError | UnauthorizedError | Bounty

union ForceSolverToAbandonBountyAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input ForceSolverToAbandonBountyAsStaffInput {
  bountyId: Int!
  reason: String!
}

union CancelBountyAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input CancelBountyAsStaffInput {
  bountyId: Int!
  reason: String!
}

union AbandonBountyOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Bounty

input AbandonBountyInput {
  bountyId: Int!
}

union RemoveBountyApplicationAsModeratorOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyApplication

input RemoveBountyApplicationAsModeratorInput {
  bountyApplicationId: Int!
  reason: String!
}

union RemoveBountyApplicationAsApplicantOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | BountyApplication

input RemoveBountyApplicationAsApplicantInput {
  bountyApplicationId: Int!
}

union ReviewBountyHunter =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyHunterReview

input ReviewBountyHunterInput {
  bountyId: Int!
  userToReviewId: Int!
  communicationRating: Int!
  qualityRating: Int!
  timelinessRating: Int!
  reviewText: String
}

union RemoveBountyHunterReviewAsStaffOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | BountyHunterReview

input RemoveBountyHunterReviewAsStaffInput {
  bountyHunterReviewId: Int!
  reason: String!
}

union SendBountyChatOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | TooManyRequestsError
  | ServiceUnavailable
  | BountyChatMessage

input SendBountyChatInput {
  bountyApplicationId: Int!
  message: String!
}

union MarkBountyChatReadOutput =
    NotFoundError
  | UnauthorizedError
  | BountyChatMessage

input MarkBountyChatReadInput {
  bountyApplicationId: Int!
}

union HireBountyHunterServiceOutput =
    UserError
  | TooManyRequestsError
  | UnauthorizedError
  | NotFoundError
  | ServiceUnavailable
  | HireBountyHunterServiceSuccess

type HireBountyHunterServiceSuccess {
  hireRequestId: String!
  bountyHunterService: BountyHunterService!
}

input HireBountyHunterServiceInput {
  bountyHunterServiceId: Int!
  email: String!
}

union createCyclesStripeCheckoutSession =
    UserError
  | UnauthorizedError
  | CreateCyclesStripeCheckoutSessionResult

type CreateCyclesStripeCheckoutSessionResult {
  sessionUrl: String!
}

input CreateCyclesStripeCheckoutSessionInput {
  quantity: Int!
  purchaseType: CyclesPurchaseType!
  redirectDestination: CyclesRedirectDestinationType

  # Title of a Repl if redirectDestination is to the Workspace
  redirectReplTitle: String
  redirectTipSurface: CyclesCheckoutRedirectTipSurface
}

# The type of purchase (one-time payment or subscription)
enum CyclesPurchaseType {
  oneTime
}

# Destination in Replit app to redirect the user to after successful checkout
enum CyclesRedirectDestinationType {
  newReplModal
  cyclesPage
  workspace
  profile
  bounties
  tipSurface
  account
}

# Tip surface to redirect to, if redirectDestination is tipSurface
input CyclesCheckoutRedirectTipSurface {
  # Username of the tip surface owner
  username: String!

  # Slug of the tip surface
  slug: String!

  # Type of tip surface
  surfaceType: CyclesCheckoutTippableSurfaceType!

  # Amount of Cycles the user intended to tip
  desiredAmount: Int!
}

# Type of tip surface
enum CyclesCheckoutTippableSurfaceType {
  repl
  theme
}

# Power Up to purchase after a successful checkout
enum CyclesCheckoutPurchasePowerUpType {
  ghostwriter
}

union BulkModerateOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | BulkModerateResult

type BulkModerateResult {
  # The success message
  message: String!

  # The moderation action taken
  action: String!

  # The reason for moderating the repls, comments, users, etc.
  reason: String!
}

input BulkModerateInputArg {
  # The ids of the comments for comment moderation actions
  commentIds: [Int!]

  # The ids of the repls, comments, users as string
  replIds: [String!]
  userIds: [Int!]

  # The ids of the posts for post moderation actions
  postIds: [Int!]
  action: BulkModerateAction!

  # The reason for moderating the repls, comments, users, etc.
  reason: String!
}

enum BulkModerateAction {
  banCommunityUser
  banUser
  deleteRepl
  hideComment
  hidePost
  poisonRepl
  reportRepl
  reportReplComment
}

union UpdateGhostwriterPowerUpOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | CurrentUser

input UpdateGhostwriterPowerUpInput {
  active: Boolean!
}

union CreateNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | CreateNeonDatabaseResult

type CreateNeonDatabaseResult {
  projectId: String!
  databaseId: Int!
  databaseName: String!
  connectionString: String!
  isFrozen: Boolean!
}

input CreateNeonDatabaseInput {
  replId: String!
}

union DeleteNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | DeleteNeonDatabaseResult

type DeleteNeonDatabaseResult {
  success: Boolean!
}

input DeleteNeonDatabaseInput {
  replId: String!
  databaseId: Int!
}

union FreezeNeonDatabaseOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | FreezeNeonDatabaseResult

type FreezeNeonDatabaseResult {
  success: Boolean!
}

input FreezeNeonDatabaseInput {
  replId: String!
  neonProjectId: String!
}

union UnfreezeNeonDatabaseOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | UnfreezeNeonDatabaseResult

type UnfreezeNeonDatabaseResult {
  success: Boolean!
}

input UnfreezeNeonDatabaseInput {
  replId: String!
  neonProjectId: String!
}

union FailHostingBuildOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | FailHostingBuildResult

type FailHostingBuildResult {
  deployment: HostingDeployment!
  build: HostingBuild!
  activityLog: HostingActivityLog!
}

input FailHostingBuildInput {
  buildId: String!
  targetDeploymentId: String!
}

union BoostRepl2Output =
    PaymentError
  | UserError
  | UnauthorizedError
  | BoostRepl2Result

type BoostRepl2Result {
  repl: Repl!
  currentUser: CurrentUser!
}

input BoostRepl2Input {
  replId: String!

  # The SKU of the Boost to use or off to turn off Boost.
  setting: BoostSettingEnum!

  # Expected Cycles cost for the Boost. Will prevent the mutation from Boosting if the actual Cycles cost is greater than expected.
  expectedCyclesCost: Int
}

enum BoostSettingEnum {
  off
  boost_8cpu_16ram
  boost_16cpu_32ram
  boost_32cpu_64ram
}

union ImageScanType = UserError | UnauthorizedError | ImageScan

union RegisterPushDeviceSessionOutput =
    UserError
  | UnauthorizedError
  | RegisterPushDeviceSessionResult

type RegisterPushDeviceSessionResult {
  deviceId: String
  didCreate: Boolean
}

input RegisterPushDeviceSessionInput {
  deviceId: String!
  token: String!
  tokenType: PushNotificationTokenType!
}

# The token type for push notifications
enum PushNotificationTokenType {
  expo
  web
}

union UnregisterPushDeviceSessionOutput =
    UserError
  | NotFoundError
  | UnregisterPushDeviceSessionResult

type UnregisterPushDeviceSessionResult {
  success: Boolean!
  unregisteredCount: Int!
}

input UnregisterPushDeviceSessionInput {
  deviceId: String!
}

union InstallExtensionOutput =
    UnauthorizedError
  | UserError
  | ExtensionInstallation

union AddReplIdentityAllowedRepl = NotFoundError | UnauthorizedError | Repl

input AddReplIdentityAllowedReplInput {
  replId: String!
}

union DeleteReplIdentityAllowedRepl = NotFoundError | UnauthorizedError | Repl

input DeleteReplIdentityAllowedReplInput {
  replId: String!
}

union UninstallExtensionOutput =
    NotFoundError
  | UserError
  | ExtensionInstallation

union DeployHostingBuild2Output =
    UserError
  | NotFoundError
  | UnauthorizedError
  | TooManyRequestsError
  | DeployHostingBuild2Result

type DeployHostingBuild2Result {
  build: HostingBuild!
  targetDeployment: HostingDeployment!
}

input DeployHostingBuild2Input {
  replId: String!

  # Target deployment for build. If null build is treated as first build and new deployment will be created if none already exist.
  targetDeploymentId: String
  targetMachineConfigurationId: String
  maxMachineInstances: Int

  # The job settings if build provider is cron.
  machineJob: DeployHostingBuild2MachineJob

  # The subdomain to use with replit.app. If none is provided, we use slug-username.
  subdomain: String

  # The context in which this mutation is invoked. Used for analytics.
  context: String
  commands: DeployHostingBuild2Commands!
  envVars: [DeployHostingBuild2EnvVar!]
  provider: HostingBuildProvider!
  appType: DeployHostingBuildAppType!
}

input DeployHostingBuild2MachineJob {
  timezone: String!
  crontab: String!
  timeoutSeconds: Int
}

input DeployHostingBuild2Commands {
  build: String
  run: String!
}

input DeployHostingBuild2EnvVar {
  name: String!
  value: String!
}

enum DeployHostingBuildAppType {
  cloud_run
  server
  static
  worker
  cron
}

union SendPushToStaff = UnauthorizedError | SendPushToStaffResult

# If the notification was sent successfully
type SendPushToStaffResult {
  success: Boolean!
}

input SendPushToStaffInput {
  messageTitle: String!
  messageBody: String!
  url: String
}

union DeleteThreadMessageOutput = UserError | AnnotationAnchor

union ChangeSubscriptionOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | ChangeSubscriptionResult

type ChangeSubscriptionResult {
  currentUser: CurrentUser!
  paymentIntentStatus: UpdateSubscriptionResultPaymentIntentStatus
  hostedInvoiceUrl: String
}

enum UpdateSubscriptionResultPaymentIntentStatus {
  succeeded
  requires_payment_method
  requires_action
}

input ChangeSubscriptionInput {
  # The plan prefix of the subscription type to change the users current subscription to
  newPlanPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  newPlanPeriod: SelectableSubscriptionPeriodTypesEnum!
}

union AdminRemoveUserImageOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | User

union CreateSetupIntentOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateSetupIntentResult

type CreateSetupIntentResult {
  clientSecret: String!
}

input CreateSetupIntentInput {
  # The name of the customer to create on Stripe if one does not yet exist.
  customerName: String
}

union UpdateCyclesAutoRefillConfigurationOutput =
    UserError
  | UnauthorizedError
  | CurrentUser

input UpdateCyclesAutoRefillConfigurationInput {
  # Whether Auto-Refill is enabled
  enabled: Boolean!

  # USD cents maximum purchase total per calendar month. If unspecified there is no maximum.
  monthlyBudget: Int
}

union AppStoreCustomerOutput =
    UserError
  | UnauthorizedError
  | AppStoreCustomerResult

type AppStoreCustomerResult {
  appAccountToken: String!
}

union PlayStoreCustomerOutput =
    UserError
  | UnauthorizedError
  | PlayStoreCustomerResult

type PlayStoreCustomerResult {
  appAccountToken: String!
}

union CreateReplitOneTimeCheckoutSessionOutput =
    UserError
  | UnauthorizedError
  | PaymentError
  | TooManyRequestsError
  | CreateReplitOneTimeCheckoutSessionResult

type CreateReplitOneTimeCheckoutSessionResult {
  clientSecret: String!
  checkoutSession: ReplitCheckoutSession!

  # The current user, can be used to refetch Auto-Refill configuration or payment method to update the client cache
  currentUser: CurrentUser!
}

input CreateReplitOneTimeCheckoutSessionInput {
  # The number of Cycles to purchase
  cyclesQuantity: Int!

  # The PowerUp to apply after the Cycles purchase
  postPurchasePowerUp: PostPurchasePowerUp

  # If specified, update the user's Auto-Refill configuration
  cyclesAutoRefillConfiguration: UpdateCyclesAutoRefillConfigurationInput

  # The name of the customer to be used if a new customer needs to be created
  customerName: String
}

input PostPurchasePowerUp {
  replPowerUp: PostPurchaseReplPowerUp!
}

input PostPurchaseReplPowerUp {
  replId: String!
  type: PostPurchaseReplPowerUpOrderTypeEnumType!
  sku: PostPurchaseReplPowerUpSkuEnumType!
}

enum PostPurchaseReplPowerUpOrderTypeEnumType {
  hosting_tier
}

enum PostPurchaseReplPowerUpSkuEnumType {
  hosting_tier_e2_micro
  hosting_tier_e2_small
  hosting_tier_e2_medium
  hosting_tier_n1_custom_1_4
  hosting_tier_e2_standard_2
  hosting_tier_e2_standard_4
}

union CreateReplitPlanCheckoutSessionOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateReplitPlanCheckoutSessionResult

type CreateReplitPlanCheckoutSessionResult {
  clientSecret: String!
  checkoutSession: ReplitCheckoutSession!
  currentUser: CurrentUser!
}

input CreateReplitPlanCheckoutSessionInput {
  # The plan prefix of the subscription type to change the users current subscription to
  planPrefix: SelectableSubscriptionPrefixTypesEnum!

  # The plan period of the subscription type to change the users current subscription to
  planPeriod: SelectableSubscriptionPeriodTypesEnum!

  # The name of the customer to be used if a new customer needs to be created
  customerName: String
}

union AdminRemoveReplIconOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Repl

union adminRemoveCoverImageOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Repl

union CreateGithubRepoOutput =
    UserError
  | UnauthorizedError
  | CreateGithubRepoResult

type CreateGithubRepoResult {
  remoteUrl: String!
}

input CreateGithubRepoInput {
  name: String!
  description: String
  homepage: String
  isPrivate: Boolean!
  ownerType: GithubRepoOwnerType!
}

# The owner type of a GitHub repository
enum GithubRepoOwnerType {
  user
  organization
}

union SetHostingTierOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | SetHostingTierResult

type SetHostingTierResult {
  repl: Repl!
  currentUser: CurrentUser!
}

input SetHostingTierInput {
  replId: String!

  # The desired SKU of the hosting tier or whether to suspend it.
  sku: HostingTierPowerUpSku!
}

union SendDeploymentLifecycleCommandOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | SendDeploymentLifecycleCommandResult

type SendDeploymentLifecycleCommandResult {
  repl: Repl!
  currentUser: CurrentUser!
}

input SendDeploymentLifecycleCommandInput {
  replId: String!

  # The desired lifecycle command to be sent.
  command: SendDeploymentLifecycleCommandType!
  buildId: String
  machineConfigurationId: String
  maxMachineInstances: Int
}

enum SendDeploymentLifecycleCommandType {
  update_machine_configuration
  resume
  suspend
  destroy
}

union UpdateExtensionOutput = UserError | Extension

union SetUserKeybindingsOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Keybindings

input SetUserKeybindingsInput {
  environment: KeybindingsEnvironmentEnum!
  platform: KeybindingsPlatformEnum!
  keybindings: JSON!
}

union CreateExtensionOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | Extension

union CompleteGoogleSubscriptionPurchaseOutput =
    UserError
  | UnauthorizedError
  | CompleteGoogleSubscriptionPurchaseResult

type CompleteGoogleSubscriptionPurchaseResult {
  success: Boolean!
  outcomeMessage: CompleteGoogleSubscriptionPurchaseMessage
}

type CompleteGoogleSubscriptionPurchaseMessage {
  userFacingMessage: String!
  debugMessage: String!
}

union CompleteAppleSubscriptionPurchaseOutput =
    UserError
  | UnauthorizedError
  | CompleteAppleSubscriptionPurchaseResult

type CompleteAppleSubscriptionPurchaseResult {
  success: Boolean!
  outcomeMessage: CompleteAppleSubscriptionPurchaseMessage
}

type CompleteAppleSubscriptionPurchaseMessage {
  userFacingMessage: String!
  debugMessage: String!
}

union SetExtensionListedOutput = UserError | UnauthorizedError | Extension

union SetExtensionBlessedOutput = UserError | UnauthorizedError | Extension

union SetExtensionFeaturedOutput = UserError | UnauthorizedError | Extension

union BatchDeleteReplsOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | BatchDeleteReplsResult

type BatchDeleteReplsResult {
  # The repls that were deleted
  repls: [Repl!]
}

input BatchDeleteReplsInput {
  ids: [String!]!
}

union FrontSupportRequestOutput =
    UserError
  | UnauthorizedError
  | TooManyRequestsError
  | FrontSupportRequestSuccess

type FrontSupportRequestSuccess {
  success: Boolean!
}

input FrontSupportRequestInput {
  title: String!
  body: String!
  type: SupportCategoryType!
  attachments: [Int!]
  clientInformation: FrontSupportRequestClientSideInput
  projects: [String!]
}

enum SupportCategoryType {
  AccountBilling
  BugReport
  Feedback
  Question
  Other
  Security
  Cycles
  Account
  Billing
  Technical
}

input FrontSupportRequestClientSideInput {
  pageUrl: String
  browser: String
  device: String
}

union UpdateHomeModuleOutput =
    UserError
  | UnauthorizedError
  | UpdateHomeModuleResult

type UpdateHomeModuleResult {
  tour: TourSeen!
}

input UpdateHomeModuleInput {
  tourId: String!
  enabled: Boolean!
}

union CheckClientVersionResult = CheckClientVersionOutput

union LinkHostingDeploymentDomain =
    UnauthorizedError
  | ServiceUnavailable
  | NotFoundError
  | UserError
  | HostingDeployment

input LinkHostingDeploymentDomainInput {
  hostingDeploymentId: String!
  domain: String!
}

union UnlinkHostingDeploymentDomain =
    UnauthorizedError
  | ServiceUnavailable
  | NotFoundError
  | HostingDeployment

input UnlinkHostingDeploymentDomainInput {
  hostingDeploymentDomainId: Int!
}

union UnlinkLegacyReplDomain =
    UnauthorizedError
  | ServiceUnavailable
  | NotFoundError
  | Repl

input UnlinkLegacyReplDomainInput {
  replDomainId: Int!
  transferToHostingDeploymentId: String
}

union WorkflowFeedbackOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | WorkflowFeedbackOutputType

type WorkflowFeedbackOutputType {
  id: String!
}

input WorkflowFeedbackInputType {
  ghostwriterChatFeedback: GhostwriterChatFeedbackType
}

input GhostwriterChatFeedbackType {
  chatHistory: String!
  feedback: String!
  metadata: String!
}

union VerifyHostingDeploymentDomain =
    UnauthorizedError
  | NotFoundError
  | UserError
  | HostingDeploymentDomain

input VerifyHostingDeploymentDomainInput {
  hostingDeploymentDomainId: Int!
}

union DeleteExtensionOutput = UnauthorizedError | UserError | Extension

union SendSmsVerificationOutput =
    UnauthorizedError
  | UserError
  | TooManyRequestsError
  | SendSmsVerificationResult

type SendSmsVerificationResult {
  success: Boolean!
}

input SendSmsVerificationInput {
  phoneNumber: String!

  # the reason that the user was asked to sms verify
  context: SmsVerificationContext
}

# the reason that someone was asked to sms verify. e.g. starting a trial.
enum SmsVerificationContext {
  # the user was asked to sms verify to be eligible for a trial
  trial

  # user was asked to verify to deploy their repl
  deployments

  # user verified their phone number not in response to a specific request. we present this option on the account page.
  voluntary

  # user was asked to verify to create a neon ubb database
  neon

  # user was asked to verify for usage-based dev compute
  compute

  # user was asked to verify for usage-based dev egress
  egress

  # user was asked to verify for usage-based dev storage
  storage

  # user was asked to verify to apply for a bounty
  bountyApplication

  # user was asked to verify to use object storage
  objectStorage
}

union ConfirmSmsVerificationOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | ConfirmSmsVerificationResult

type ConfirmSmsVerificationResult {
  success: Boolean!
}

input ConfirmSmsVerificationInput {
  phoneNumber: String!
  code: String!

  # the reason that the user was asked to sms verify
  context: SmsVerificationContext
}

union ChangeUsernameOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | CurrentUser

input ChangeUsernameInput {
  newUsername: String!
}

union UpdateUsageBasedBillingBudgetOutput =
    UserError
  | UnauthorizedError
  | CurrentUser

input UpdateUsageBasedBillingBudgetInput {
  # USD maximum purchase total per calendar month. If unspecified there is no maximum.
  monthlyBudgetUsd: Int
}

union CreateUserWorkspaceLayoutOutput = UserError | UserWorkspaceLayout

input CreateUserWorkspaceLayoutInput {
  name: String!
  state: JSON!
}

union UpdateUserWorkspaceLayoutOutput =
    NotFoundError
  | UserError
  | UserWorkspaceLayout

input UpdateUserWorkspaceLayoutInput {
  id: String!
  name: String
  state: JSON
}

union DeleteUserWorkspaceLayoutOutput = NotFoundError | CurrentUser

input DeleteUserWorkspaceLayoutInput {
  id: String!
}

union SaveUserAuthOutput =
    UnauthorizedError
  | UserError
  | TooManyRequestsError
  | ServiceUnavailable
  | CurrentUser

# Input required for saving OAuth provider state
input SaveUserAuthInput {
  # The OAuth provider for which to save state
  provider: String!

  # The OAuth provider access token
  token: String!

  # The OAuth scopes associated with the state
  scopes: [String!]!
}

union SetTrialBillingPeriodOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | TooManyRequestsError
  | SetTrialBillingPeriodResult

type SetTrialBillingPeriodResult {
  currentUser: CurrentUser!
}

input SetTrialBillingPeriodInput {
  billingPeriod: SelectableSubscriptionPeriodTypesEnum!
}

union ReportExtensionOutput =
    UnauthorizedError
  | TooManyRequestsError
  | UserError
  | Extension

union ClaimAnnualPromotionOutput =
    PaymentError
  | UserError
  | UnauthorizedError
  | TooManyRequestsError
  | ClaimAnnualPromotionResult

type ClaimAnnualPromotionResult {
  currentUser: CurrentUser!
}

union DeployExtension2Output = UserError | TooManyRequestsError | Extension

union AddPublicSshKeyResult =
    UnauthorizedError
  | UserError
  | ServiceUnavailable
  | CurrentUser

input AddPublicSshKeyInput {
  # Public SSH key to add to the user's account
  key: String!

  # Label for the public SSH key
  label: String!
}

union DeletePublicSshKeyResult =
    UnauthorizedError
  | NotFoundError
  | ServiceUnavailable
  | CurrentUser

input DeletePublicSshKeyInput {
  # Public SSH key id to delete from the user's account
  id: String!
}

union CreateBucketOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Bucket

input CreateBucketInput {
  replId: String!
}

union DeleteBucketOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | Bucket

input DeleteBucketInput {
  bucketId: String!
}

union AddOrInviteReplMultiplayerResult =
    UnauthorizedError
  | NotFoundError
  | UserError
  | AddOrInviteReplMultiplayerOuput

type AddOrInviteReplMultiplayerOuput {
  result: MultiplayerInviteOrPermission!
}

union MultiplayerInviteOrPermission = MultiplayerInvite | ReplPermission

input AddOrInviteReplMultiplayerInput {
  # The target for the invite. This can be either an existing user, targeted by username, or a non-user targeted by email.
  target: MultiplayerInviteTarget!

  # The Repl ID for which to add the target
  replId: String!

  # The permission level we want to grant to the target.
  level: ReplPermissionLevel!
}

input MultiplayerInviteTarget {
  # Whether the target value is an email or username.
  method: MultiplayerInviteMethod!

  # The target value, the type of which is determined using the method field.
  value: String!
}

enum MultiplayerInviteMethod {
  username
  email
}

input UpdateTeamReplPresenceInput {
  sessionId: String!
  branch: String
}

union CreateOrgGroupOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | OrgGroup

input CreateOrgGroupInput {
  # The organization under which to create the group.
  orgId: String!

  # The new group's name.
  name: String!

  # The color to associate with the group.
  color: OrgGroupColor!

  # A list of group IDs that own the new group. The requester must belong to at least one of these groups.
  ownerGroupIds: [String!]!
}

union RemoveOrgMemberOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Org

input RemoveOrgMemberInput {
  # The organization from which we want to remove a member.
  orgId: String!

  # The user we want to remove from the org
  userId: Int!
}

union DeleteOrgOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | CurrentUser

input DeleteOrgInput {
  # The org which we want to delete.
  orgId: String!
}

union ExportTeamsEduTeacherOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | CurrentUser

union ExportTeamsEduStudentOutput =
    NotFoundError
  | UnauthorizedError
  | UserError
  | CurrentUser

union AddOrgGroupMemberOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | OrgGroupMember

input AddOrgGroupMemberInput {
  # The group to which we want to add a member.
  orgGroupId: String!

  # The user we want to add to the group
  userId: Int!
}

union RemoveOrgGroupMemberOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | OrgGroup

input RemoveOrgGroupMemberInput {
  # The group from which we want to remove a member.
  orgGroupId: String!

  # The user we want to remove from the group.
  userId: Int!
}

union AddOrInviteOrgMemberOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Org

input AddOrInviteOrgMemberInput {
  # The group from which we want to remove a member.
  orgId: String!

  # Whether to add an existing user by username, or a non-user by email.
  mode: AddOrInviteOrgMemberMode!

  # The username of the user to add, or the email to invite.
  value: String!

  # The system group to which the member should be added.
  systemGroup: SystemOrgGroupType!

  # Custom groups to which the new member should be added.
  additionalGroupIds: [String!]!
}

enum AddOrInviteOrgMemberMode {
  email
  username
}

union CancelScheduledJobExecutionOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | CancelScheduledJobExecutionResult

type CancelScheduledJobExecutionResult {
  execution: ScheduledJobExecution!
}

input CancelScheduledJobExecutionInput {
  # The deployment ID associated with the execution to cancel
  deploymentId: String!

  # The execution ID to cancel
  executionId: String!
}

union ExecuteScheduledJobOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | ExecuteScheduledJobResult

type ExecuteScheduledJobResult {
  execution: ScheduledJobExecution!
}

input ExecuteScheduledJobInput {
  # The ID of the deployment to execute
  deploymentId: String!
}

union UpdateOrgGroupOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | OrgGroup

input UpdateOrgGroupInput {
  # The group we want to update.
  orgGroupId: String!

  # A new name for the group.
  name: String

  # The new color to associate with the group.
  color: OrgGroupColor
}

union UpdateOrgGroupScopesOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | OrgGroup

input UpdateOrgGroupScopesInput {
  # The group we want to update.
  orgGroupId: String!

  # A list of org scopes to add or update on the group.
  orgScopes: [UpsertOrgGroupOrgScope!]!

  # A list of group scopes to add or update on the group.
  groupScopes: [UpsertOrgGroupOrgGroupScope!]!

  # A list of Repl scopes to add or update on the group.
  replScopes: [UpsertOrgGroupReplScope!]!

  # A list of scopes to remove from the group.
  removeScopes: [RemoveOrgGroupScope!]!
}

input UpsertOrgGroupOrgScope {
  # The resource ID to which the scope applies.
  resourceId: String!

  # The role to grant on the resource.
  role: OrgGroupOrgScopeRole!
}

input UpsertOrgGroupOrgGroupScope {
  # The resource ID to which the scope applies.
  resourceId: String!

  # The role to grant on the resource.
  role: OrgGroupOrgGroupScopeRole!
}

# A role associated with a group.
enum OrgGroupOrgGroupScopeRole {
  restricted
  viewer
  manager
  owner
}

input UpsertOrgGroupReplScope {
  # The resource ID to which the scope applies.
  resourceId: String!

  # The role to grant on the resource.
  role: OrgGroupReplScopeRole!
}

# A role associated with a Repl.
enum OrgGroupReplScopeRole {
  viewer
  editor
  deployer
  owner
}

input RemoveOrgGroupScope {
  # Whether the scope to remove is tied to a group or a Repl.
  resourceType: OrgGroupRemoveResourceType!

  # The resource ID to which the scope applies.
  resourceId: String!
}

# The resource type to remove.
enum OrgGroupRemoveResourceType {
  group
  repl
}

union DeleteOrgGroupOutput = UnauthorizedError | NotFoundError | UserError | Org

input DeleteOrgGroupInput {
  # The group we want to delete.
  orgGroupId: String!
}

union UpdateReplGitStateOutput =
    UserError
  | UnauthorizedError
  | NotFoundError
  | Repl

input UpdateReplGitStateInput {
  replId: String!

  # a JSON object containing the git information.
  gitInfo: JSONObject!
}

union UpdateOrgProfileOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Org

input UpdateOrgProfileInput {
  # The org which we want to update.
  orgId: String!

  # Updated name of the org
  name: String

  # Updated image id
  imageId: Int
}

union CreateProjectOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | ServiceUnavailable
  | Project

input CreateProjectInput {
  # The main Repl that represents the root of the project
  mainReplId: String!

  # An optional 1st dev fork of the main Repl to register in the project when the project is initialized
  devReplId: String

  # The org that owns this project
  orgId: String!
}

union DeleteProjectOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | DeleteProjectResult

type DeleteProjectResult {
  success: Boolean!
}

input DeleteProjectInput {
  projectId: String!
}

union SetFiletypeAssociationOutput =
    UserError
  | UnauthorizedError
  | UserFiletypeAssociations

type UserFiletypeAssociations {
  associations: JSON
}

input FiletypeAssociationInput {
  fileExtension: String!
  newAssociation: NewAssociationInput
}

input NewAssociationInput {
  extensionId: String!
  fileHandlerId: String!
}

union CreateOrgSetupIntentOutput =
    UserError
  | NotFoundError
  | UnauthorizedError
  | TooManyRequestsError
  | CreateOrgSetupIntentResult

type CreateOrgSetupIntentResult {
  clientSecret: String!
}

input CreateOrgSetupIntentInput {
  # The id of the org to create a setup intent for.
  orgId: String!
}

union AcceptOrgInviteOutput = UnauthorizedError | UserError | Org

input AcceptOrgInviteInput {
  # The organization under which the invite was created.
  orgId: String!

  # The invitation code to accept.
  inviteCode: String!
}

input PingOrgReplPresenceSessionInput {
  sessionId: String!
}

union UpdateOrgContextOutput =
    UnauthorizedError
  | NotFoundError
  | UserError
  | Org

input UpdateOrgContextInput {
  # The org context which we want to store.
  orgId: String!
}

# The top level entry point for subscribing to graph events
type RootSubscriptionType {
  # Updates to annotations in a given repl. Returns the updated annotation
  annotationUpdatesByRepl(replId: String!): AnnotationAnchor

  # A subscription to events regarding changes to the online status of repls in a team
  teamReplConnections(teamId: Int!): TeamConnectionEvent!

  # The subscription used to register a connection to a repl.
  replConnection(replId: String!): Boolean

  # Streams the notification count to current user
  notificationCount: Int!
  threadPreview(threadId: String!): ThreadPreview

  # Updates to the current user's write permissions for a given repl.
  currentUserCanWrite(replId: String!): Boolean!
  latestBountyChatMessage(
    input: LatestBountyChatMessageInput!
  ): BountyChatMessage

  # Returns repl hosting deploy action updates.
  hostingBuildDeployActionUpdates(
    input: HostingBuildDeployActionUpdatesInput!
  ): HostingBuildDeployActionUpdateEvent!

  # Returns hosting deployment log updates.
  hostingDeploymentLogUpdates(
    input: HostingDeploymentLogUpdatesInput!
  ): ReplLog!

  # Subscribe to the Nix Migration progress for a given Repl.
  migrate2nix(replId: String!): String

  # Returns extension deploy action updates.
  extensionBuildDeployActionUpdates(
    input: ExtensionBuildDeployActionUpdatesInput!
  ): ExtensionBuildDeployActionUpdateEvent!

  # Start a user's session
  startTeamReplPresenceSession(input: StartTeamReplPresenceInput!): Boolean

  # Events for when a session is created/update or ended
  teamReplPresenceSessionEvents(
    input: TeamRepoPresenceEventsInput!
  ): TeamRepoPresenceEvent

  # Start a user's session for an org repl
  startOrgReplPresenceSession(input: StartOrgReplPresenceSessionInput!): Boolean

  # Events for when a session is created/update or ended
  orgReplPresenceSessionEvents(
    input: OrgReplPresenceSessionEventsInput!
  ): OrgPresenceEvent
}

# Events used for sending information on team connections
union TeamConnectionEvent =
    RemoveReplConnectionsEvent
  | UpdateReplConnectionsEvent

# The event called when there are no longer any connections to a Repl.
type RemoveReplConnectionsEvent {
  replId: String!

  # The time when the data was returned
  epoch: DateTime!
}

# The event sent when the list of connected users for a Repl changes or is created.
type UpdateReplConnectionsEvent {
  # The Repl which users are connected to
  repl: Repl!

  # The users that are connected to the Repl
  users: [User!]!

  # The time when the data was returned
  epoch: DateTime!
}

type ThreadPreview {
  userId: Int!
  messageId: String!
  message: String
}

input LatestBountyChatMessageInput {
  bountyApplicationId: Int!
}

input HostingBuildDeployActionUpdatesInput {
  buildId: String!
}

input HostingDeploymentLogUpdatesInput {
  deploymentId: String!

  # Execution ID to filter logs based on
  executionId: String

  # Start of log datetime range to filter by
  start: DateTime

  # End of log datetime range to filter by
  end: DateTime

  # Log message substring to filter by (currently exact match)
  message: String

  # Log level to filter by
  level: LogLevel
}

# An extension deploy action update event
union ExtensionBuildDeployActionUpdateEvent =
    ExtensionBuildDeployLogAction
  | ExtensionBuildDeployStatusAction

type ExtensionBuildDeployLogAction {
  log: String!
}

type ExtensionBuildDeployStatusAction {
  build: HostingBuild!
  status: HostingBuildStatus!
  message: String
}

input ExtensionBuildDeployActionUpdatesInput {
  extensionId: String!
}

input StartTeamReplPresenceInput {
  replId: String!
  sessionId: String!
  branch: String!
}

#
union TeamRepoPresenceEvent =
    PresenceSessionPingEvent
  | PresenceSessionLeaveEvent
  | PresenceSessionInitEvent

#
type PresenceSessionPingEvent {
  session: PresenceSession!
}

#
type PresenceSessionLeaveEvent {
  sessionId: String!
}

#
type PresenceSessionInitEvent {
  sessions: [PresenceSession!]!
}

input TeamRepoPresenceEventsInput {
  teamId: Int!
  gitRemoteUrl: String
}

input StartOrgReplPresenceSessionInput {
  replId: String!
  sessionId: String!
}

union OrgPresenceEvent =
    OrgPresenceSessionPingEvent
  | OrgPresenceSessionLeaveEvent
  | OrgPresenceSessionInitEvent

type OrgPresenceSessionPingEvent {
  session: OrgPresenceSession!
}

type OrgPresenceSession {
  id: String!
  repl: Repl
  user: User
  expiresAt: DateTime!
}

type OrgPresenceSessionLeaveEvent {
  sessionId: String!
}

type OrgPresenceSessionInitEvent {
  sessions: [OrgPresenceSession!]!
}

input OrgReplPresenceSessionEventsInput {
  orgId: String!
  projectId: String
}
